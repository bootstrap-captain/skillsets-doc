# æ•°æ®åŸºç¡€

```bash
# äºŒå‰æ ‘
- æ¯ä¸ªèŠ‚ç‚¹ï¼Œæœ€å¤šåªå­˜åœ¨ä¸¤ä¸ªå­èŠ‚ç‚¹

# æ ¹èŠ‚ç‚¹
# å¶å­èŠ‚ç‚¹

# æ»¡äºŒå‰æ ‘
- æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå¶å­èŠ‚ç‚¹

# å®Œå…¨äºŒå‰æ ‘
- å…¶ä½™å±‚éƒ½å¿…é¡»å¡«æ»¡ï¼Œæœ€åä¸€å±‚å¯å¡«æ»¡å¯ä¸å¡«æ»¡
- æœ€åä¸€å±‚ï¼šå¿…é¡»ä»å·¦å‘å³å¡«å……

# Nå‰æ ‘
- ä¸€ä¸ªç»“ç‚¹å¯èƒ½æœ‰å¤šä¸ªå­©å­
```

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java
public class Node {
    int val;
    List<Node> children;

    public Node(int val) {
        this.val = val;
    }

    public Node(int val, List<Node> children) {
        this.val = val;
        this.children = children;
    }
}
```

## å¹¿åº¦ä¼˜å…ˆ-BFS

- Bredth First Search:  å¤„ç†å®Œå½“å‰å±‚çš„ç»“ç‚¹çš„å€¼ä¹‹åï¼Œæ‰å»å¤„ç†ä¸‹ä¸€å±‚çš„ç»“æœ

### ğŸ˜[102.å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- æ¯å±‚ä»å·¦åˆ°å³å°è£…ï¼Œä»é¡¶åˆ°åº•
- è¿­ä»£å’Œé€’å½’å†™æ³•ä¸€æ ·ï¼Œåç»­ç»Ÿä¸€ç”¨è¿­ä»£æ¥å†™

#### é˜Ÿåˆ— + è¿­ä»£

```bash
# é˜Ÿåˆ—æ€è·¯
- æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
- å¤´å¼¹å‡ºï¼Œå¤„ç†å½“å‰èŠ‚ç‚¹ï¼Œç„¶åå°†å½“å‰èŠ‚ç‚¹çš„å·¦å³å­©å­ä¾æ¬¡å…¥é˜Ÿ
- ç›´åˆ°é˜Ÿåˆ—ä¸ºç©º
```

![image-20231014115013816](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014115013816.png)

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();

    Queue<TreeNode> queue = new LinkedList<>();
    if (root == null) {
        return res;
    }

    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subRes = new ArrayList<>();
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            subRes.add(poll.val);
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }
            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        currentLayerSize = nextLayerSize;
        res.add(subRes);
    }
    return res;
}
```

#### é˜Ÿåˆ— + é€’å½’

- å…¶å®å°±æ˜¯ä¸Šé¢çš„é€’å½’å†™æ³•è€Œå·²

```java
public List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> levelOrder(TreeNode root) {
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    bfsRecur(queue);
    return res;
}

public void bfsRecur(Queue<TreeNode> queue) {
    if (queue.isEmpty()) {
        return;
    }
    List<Integer> subResult = new ArrayList<>();
    int queueSize = queue.size();
    for (int i = 0; i < queueSize; i++) {
        TreeNode poll = queue.poll();
        subResult.add(poll.val);
        if (poll.left != null) {
            queue.offer(poll.left);
        }
        if (poll.right != null) {
            queue.offer(poll.right);
        }
    }
    res.add(subResult);
    bfsRecur(queue);
}
```

### ğŸ˜ [429. N å‰æ ‘çš„å±‚åºéå†](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

- å’ŒäºŒå‰æ ‘ç±»ä¼¼

## æ·±åº¦ä¼˜å…ˆ-DFS

- Depth First Search: ä»å·¦å‘å³å¤„ç†
- ä¸‰ç§ä¸åŒçš„éå†æ–¹å¼ï¼Œå‡æ”¯æŒæ ˆ+è¿­ä»£ï¼Œé€’å½’

### âœ… [144.å‰åºéå†](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

- å…ˆå¤„ç†çˆ¶èŠ‚ç‚¹ï¼Œå†å¤„ç†å­èŠ‚ç‚¹

![image-20231029161521912](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161521912.png)

#### æ ˆ + è¿­ä»£

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) {
        return res;
    }

    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            res.add(cur.val); // å–å€¼
            cur = cur.left;
        } else {
            TreeNode pop = stack.pop();
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    return res;
}
```

#### é€’å½’

- ç»“æœæå‡åˆ°æˆå‘˜å˜é‡ï¼Œæ€§èƒ½é«˜

```java
public List<Integer> res = new ArrayList<>();

public List<Integer> preorderTraversal(TreeNode root) {
    preorder(root);
    return res;
}

public void preorder(TreeNode root) {
    if (root == null) {
        return;
    }
    res.add(root.val);
    preorder(root.left);
    preorder(root.right);
}
```

### âœ… [94.ä¸­åºéå†](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

- å¤„ç†å­èŠ‚ç‚¹çš„ä¸­é—´ï¼Œå¤„ç†çˆ¶èŠ‚ç‚¹

![image-20231029161415584](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161415584.png)

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) {
        return res;
    }

    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = stack.pop();
            res.add(pop.val);
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }
    return res;
}
```

### âœ… [145. ååºéå†](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

- å…ˆå¤„ç†å­èŠ‚ç‚¹ï¼Œå†å¤„ç†çˆ¶èŠ‚ç‚¹

![image-20231029161334384](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161334384.png)

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;

    TreeNode lastPop = null;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = stack.peek();
            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = stack.pop();
                result.add(pop.val);
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }

    return result;
}
```

### âœ… [589. N å‰æ ‘çš„å‰åºéå†](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

- é€’å½’åŒä¸Š

#### è¿­ä»£

```java
public List<Integer> preorder(Node root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) {
        return res;
    }

    Map<Node, Integer> map = new HashMap<>();
    Deque<Node> stack = new ArrayDeque<>();
    Node cur = root;

    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            res.add(cur.val);
            stack.push(cur);
            // å¤„ç†å­©å­ç»“ç‚¹ï¼Œ ç±»ä¼¼äºŒå‰æ ‘çš„cur=cur.left
            List<Node> children = cur.children;
            if (children != null && !children.isEmpty()) { // åˆ¤ç©º
                map.put(cur, 0);  // valueä»£è¡¨å­©å­çš„ç´¢å¼•ä½ç½®
                cur = children.get(0); // é€‰æœ€å·¦è¾¹çš„å…ƒç´ 
            } else {
                cur = null;
            }
        } else {
            cur = stack.peek();
            // ä¸å­˜åœ¨ä¸º0ï¼Œå­˜åœ¨ä¸º1
            int index = map.getOrDefault(cur, -1) + 1;
            List<Node> children = cur.children;
            if (children != null && children.size() > index) {
                map.put(cur, index);
                cur = children.get(index);
            } else {
                stack.pop();
                map.remove(cur);
                cur = null;
            }
        }

    }
    return res;
}
```

### âœ… [590. N å‰æ ‘çš„ååºéå†](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)

- é€’å½’åŒä¸Š

#### è¿­ä»£

```java
public List<Integer> postorder(Node root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) {
        return res;
    }

    Map<Node, Integer> map = new HashMap<>();
    Deque<Node> stack = new ArrayDeque<>();
    Node cur = root;

    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            // å¤„ç†å­©å­ç»“ç‚¹ï¼Œ ç±»ä¼¼äºŒå‰æ ‘çš„cur=cur.left
            List<Node> children = cur.children;
            if (children != null && !children.isEmpty()) { // åˆ¤ç©º
                map.put(cur, 0);  // valueä»£è¡¨å­©å­çš„ç´¢å¼•ä½ç½®
                cur = children.get(0); // é€‰æœ€å·¦è¾¹çš„å…ƒç´ 
            } else {
                cur = null;
            }
        } else {
            cur = stack.peek();
            // ä¸å­˜åœ¨ä¸º0ï¼Œå­˜åœ¨ä¸º1
            int index = map.getOrDefault(cur, -1) + 1;
            List<Node> children = cur.children;
            if (children != null && children.size() > index) {
                map.put(cur, index);
                cur = children.get(index);
            } else {
                res.add(cur.val);
                stack.pop();
                map.remove(cur);
                cur = null;
            }
        }

    }
    return res;
}
```

### âœ… [559. N å‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

#### BFS

# å±‚åºå¤„ç†

## ğŸ˜[102.å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- BFSç•¥ï¼Œä»£ç è§ä¸Š

### DFS-é€’å½’

- ä»ç¬¬ä¸€å±‚å¼€å§‹è®¡ç®—

```java
public List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> levelOrder(TreeNode root) {
    dfsRecur(root,1);
    return res;
}

public void dfsRecur(TreeNode root,int currentLayer) {
    if (root == null) {
        return;
    }

    if (res.size() < currentLayer) {
        List<Integer> subResult = new ArrayList<>();
        subResult.add(root.val);
        res.add(subResult);
    } else {
        res.get(currentLayer - 1).add(root.val);
    }

    currentLayer++;
    dfsRecur(root.left,currentLayer);
    dfsRecur(root.right,currentLayer);
}
```

| ç±»ä¼¼é¢˜ç›®                                                     | æè¿°                           | æ€è·¯             | å¤‡æ³¨                      |
| ------------------------------------------------------------ | ------------------------------ | ---------------- | ------------------------- |
| ğŸ˜ [107. äºŒå‰æ ‘çš„å±‚åºéå† II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/) | æ¯å±‚ä»å·¦åˆ°å³ï¼Œä»åº•åˆ°é¡¶         | BFS,    DFS-é€’å½’ | result.add(0, subResult); |
| ğŸ˜ [103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/) | å½“å‰å±‚å…ˆå·¦å‘å³ï¼Œä¸‹ä¸€å±‚ä»å³å¾€å·¦ | BFS,    DFS-é€’å½’ | result.add(0, subResult); |
| âœ… [637. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼](https://leetcode.cn/problems/average-of-levels-in-binary-tree/) | å½“å‰å±‚ï¼Œæ±‚å¹³å‡å€¼               | BFS,    DFS-é€’å½’ |                           |
| ğŸ˜ [515. åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/) | å±‚æœ€å¤§å€¼                       | BFS,    DFS-é€’å½’ |                           |
| ğŸ˜ [1161. æœ€å¤§å±‚å†…å…ƒç´ å’Œ](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/) | å±‚å…ƒç´ å’Œæœ€å¤§ï¼Œæœ€å°çš„é‚£ä¸ªå±‚     | BFS,    DFS-é€’å½’ |                           |
| ğŸ˜ [1302. å±‚æ•°æœ€æ·±å¶å­èŠ‚ç‚¹çš„å’Œ](https://leetcode.cn/problems/deepest-leaves-sum/) | å±‚åºå°è£…ï¼Œæ‰¾åˆ°æœ€åä¸€å±‚         | BFS,    DFS-é€’å½’ |                           |
| âœ… [111. æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) | æ ‘çš„æœ€å°æ·±åº¦                   | BFS              | ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹æ‰€åœ¨çš„å±‚    |

## ğŸ˜  [1609. å¥‡å¶æ ‘](https://leetcode.cn/problems/even-odd-tree/)

### BFS

```java
public boolean isEvenOddTree(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    boolean isOdd = true;

    while (!queue.isEmpty()) {
        int nextLayerSize = 0;

        TreeNode prev = null;

        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            if (isOdd) {
                if (poll.val % 2 == 0 || (prev != null && poll.val <= prev.val)) {
                    return false;
                }
            } else {
                if (poll.val % 2 != 0 || (prev != null && poll.val >= prev.val)) {
                    return false;
                }
            }

            prev = poll;

            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        isOdd = !isOdd;
        currentLayerSize = nextLayerSize;
    }
    return true;
}
```

## ğŸ˜ [199. å³è§†å›¾](https://leetcode.cn/problems/binary-tree-right-side-view/)

### BFS

- å±‚åºå–æ¯å±‚æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæå–ç»“æœ

### DFS-é€’å½’

- å…ˆè®¿é—®å³å­æ ‘ï¼Œå†è®¿é—®å·¦å­æ ‘
- é€’å½’æ—¶å€™ï¼Œå¦‚æœå…ˆå³å†å·¦ï¼Œåˆ™å°±æ˜¯å·¦è§†å›¾

```java
private List<Integer> rightView = new ArrayList<>();

public List<Integer> rightSideView(TreeNode root) {
    rightDfs(root, 1);
    return rightView;
}

public void rightDfs(TreeNode root, int currentLayer) {
    if (root == null) {
        return;
    }

    if (rightView.size() < currentLayer) {
        rightView.add(root.val);
    }

    currentLayer++;
    /*é¡ºåºæœ‰è®²ç©¶*/
    rightDfs(root.right, currentLayer);
    rightDfs(root.left, currentLayer);
}
```

## ğŸ˜ [513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼](https://leetcode.cn/problems/find-bottom-left-tree-value/)

- æœ€åº•å±‚æœ€å·¦è¾¹çš„å€¼

### BFS

- ä»£ç ç•¥

### DFS

#### é€’å½’

- å·¦è§†å›¾ï¼Œå…ˆå·¦å­æ ‘ï¼Œåå³å­æ ‘

```java
public List<Integer> res = new ArrayList<>();

public int findBottomLeftValue(TreeNode root) {
    dfsRecur(root, 1);
    return res.get(res.size() - 1);
}

public void dfsRecur(TreeNode root, int currentLayer) {
    if (root == null) {
        return;
    }

    if (res.size() < currentLayer) {
        res.add(root.val);
    }

    currentLayer++;
    dfsRecur(root.left, currentLayer);
    dfsRecur(root.right, currentLayer);
}
```

#### è¿­ä»£ - ååº

- æ ¹æ®ååºï¼Œä»å·¦åˆ°å³ï¼Œæ‰¾åˆ°æœ€é å·¦è¾¹çš„ï¼Œæœ€æ·±çš„ä¸€æ¡è·¯å¾„
- è¿”å›è·¯å¾„æœ€åä¸€ä¸ªå…ƒç´ 

```java
public int findBottomLeftValue(TreeNode root) {
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;

    int maxDepth = -1;
    TreeNode targetNode = null;

    TreeNode lastPop = null;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = stack.peek();
            /*å°±è¿™ä¸€ä¸ªåˆ¤æ–­*/
            if (peek.left == null && peek.right == null) { //å¶å­ç»“ç‚¹,åˆ¤æ–­ç›®æ ‡ç»“ç‚¹
                if (stack.size() > maxDepth) {
                    maxDepth = stack.size();
                    targetNode = peek;
                }
            }

            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = stack.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }

    return targetNode.val;
}
```

# è·¯å¾„

## âœ… [257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](https://leetcode.cn/problems/binary-tree-paths/)

- æ ¹è·¯å¾„åˆ°å¶å­ç»“ç‚¹ï¼Œå¶å­ç»“ç‚¹å·¦å³å‡ä¸ºç©º

### DFS - ååº- è¿­ä»£

- DFSååºéå†ï¼Œæ‰¾åˆ°æ‰€æœ‰è·¯å¾„ã€‚è§£æå¯¹åº”çš„è·¯å¾„ä¸­çš„æ•°æ®

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> res = new ArrayList<>();
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;

    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = stack.peek();
            // æ˜¯å¦åˆ°æ ¹ç»“ç‚¹äº†
            if (peek.left == null && peek.right == null) {
                res.add(getSubResult(stack));
            }
            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = stack.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return res;
}

private String getSubResult(LinkedList<TreeNode> path) {
    String[] arr = new String[path.size()];
    for (int i = 0; i < path.size(); i++) {
        arr[arr.length - i - 1] = String.valueOf(path.get(i).val);
    }
    return String.join("->", arr);
}
```

### BFS

- ç»´æŠ¤ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œä¸€ä¸ªé˜Ÿåˆ—æ”¾ç»“ç‚¹å…ƒç´ ï¼Œä¸€ä¸ªé˜Ÿåˆ—æ”¾è·¯å¾„
- å¾…ç”»å›¾

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    Queue<String> path = new LinkedList<>();

    queue.offer(root);
    path.offer(String.valueOf(root.val));

    while (!queue.isEmpty()) {
        TreeNode nodePoll = queue.poll(); // åŒæ—¶å‡º
        String pathPoll = path.poll();    // åŒæ—¶å‡º

        if (nodePoll.left == null && nodePoll.right == null) { // å¶å­ç»“ç‚¹
            result.add(pathPoll);
        }

        if (nodePoll.left != null) {
            queue.offer(nodePoll.left);
            path.offer(pathPoll + "->" + nodePoll.left.val);
        }

        if (nodePoll.right != null) {
            queue.offer(nodePoll.right);
            path.offer(pathPoll + "->" + nodePoll.right.val);
        }
    }

    return result;
}
```

| ç±»ä¼¼é¢˜ç›®                                                     | æè¿°                                | æ€è·¯                         | å¤‡æ³¨ |
| ------------------------------------------------------------ | ----------------------------------- | ---------------------------- | ---- |
| âœ… [112. è·¯å¾„æ€»å’Œ](https://leetcode.cn/problems/path-sum/)    | ä»»æ„è·¯å¾„æ€»å’Œ=targetå€¼ï¼Œè¿”å›true     | DFS - ååº- è¿­ä»£ï¼ŒDFS-é€’å½’   |      |
| ğŸ˜ [113. è·¯å¾„æ€»å’Œ II](https://leetcode.cn/problems/path-sum-ii/) | ä»»æ„è·¯å¾„æ€»å’Œ=targetå€¼ï¼Œè¿”å›æ‰€æœ‰è·¯å¾„ | DFS - ååº- è¿­ä»£             |      |
| ğŸ˜[129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode.cn/problems/sum-root-to-leaf-numbers/) | æ‰€æœ‰è·¯å¾„ä»ä¸Šåˆ°ä¸‹ç»„æˆæ•°å­—ï¼Œè¿”å›æ€»å’Œ  | DFS - ååº- è¿­ä»£             |      |
| âœ… [104. æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | æ ‘çš„æœ€å¤§æ·±åº¦                        | BFSï¼ŒDFS-ååº-è¿­ä»£ï¼ŒDFS-é€’å½’ |      |

## ğŸ˜ [113. è·¯å¾„æ€»å’Œ II](https://leetcode.cn/problems/path-sum-ii/)

- è·¯å¾„æ€»å’Œçš„å€¼ç­‰äºç›®æ ‡å€¼ï¼Œæ‰¾å‡ºæ‰€æœ‰è·¯å¾„ï¼Œå¹¶å°è£…è¿”å›

### DFS - é€’å½’-TODO

## ğŸ˜[129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

- ä»é¡¶åˆ°åº•ï¼Œç»„æˆä¸€ä¸ªè·¯å¾„ä¸Šçš„æ•´æ•°ï¼Œç„¶åè¿™äº›æ•´æ•°ç›¸åŠ 

###  DFS - é€’å½’

```java
public int sumNumbers(TreeNode root) {
    return dfsRecur(root, 0);
}

private int dfsRecur(TreeNode root, int result) {
    if (root == null) {
        return 0;
    }
    result = result * 10 + root.val;

    if (root.left == null && root.right == null) {
        return result;
    }
    return dfsRecur(root.left, result) + dfsRecur(root.right, result);
}
```

# åˆ¤æ–­

## âœ… [101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree/)

- âœ… [100. ç›¸åŒçš„æ ‘](https://leetcode.cn/problems/same-tree/)ï¼šç±»ä¼¼é€’å½’

### é€’å½’

- åˆ†åˆ«æ¯”è¾ƒå·¦å­æ ‘å’Œå³å­æ ‘

```java
public boolean isSymmetric(TreeNode root) {
    return recur(root.left, root.right);
}

public boolean recur(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    return left.val == right.val && recur(left.left, right.right) && recur(left.right, right.left);
}
```

### BFS

- åŒç«¯é˜Ÿåˆ—
- LinkedListå¯ä»¥æ·»åŠ å¤šä¸ªnullå€¼ï¼Œå› æ­¤å¦‚æœä¸€ä¸ªç»“ç‚¹ä¸ºnullæ—¶ï¼Œå°±ç›´æ¥æ·»åŠ nullå³å¯
- ä¾æ¬¡å¼¹å‡ºï¼Œå¦‚æœä¸¤ä¸ªç»“ç‚¹ä¸ä¸ä¸€æ ·ï¼Œå°±æ˜¯éå¯¹ç§°

![image-20241107092542726](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20241107092542726.png)

```java
public boolean isSymmetric(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offerFirst(root);
    queue.offerLast(root);

    while (!queue.isEmpty()) {
        TreeNode first = queue.pop();
        TreeNode second = queue.pop();
        if (first == null && second == null) {
            continue;
        }

        if (first == null || second == null) {
            return false;
        }

        if (first.val != second.val) {
            return false;
        }

        queue.offerFirst(first.left);
        queue.offerLast(first.right);
        queue.offerFirst(second.right);
        queue.offerLast(second.left);
    }

    return true;
}
```

## âœ… [572. å¦ä¸€æ£µæ ‘çš„å­æ ‘](https://leetcode.cn/problems/subtree-of-another-tree/)

### é€’å½’

- DFS(æˆ–è€…å…¶ä»–éå†æ–¹å¼)ï¼šç¬¬ä¸€æ¬¡éå†ï¼Œæ‰¾åˆ°rootä¸­ï¼Œæ‰¾åˆ°æ‰€æœ‰å’Œå­æ ‘æ ¹ç»“ç‚¹ç›¸åŒçš„ç»“ç‚¹ï¼Œå¯èƒ½åŒ…å«å¤šä¸ªç»“ç‚¹
- ä¾æ¬¡ç”¨æ‰€æœ‰ç›®æ ‡ç»“ç‚¹å’ŒsubRootè¿›è¡Œç›¸åŒæ ‘åˆ¤æ–­

## âœ… [404. å·¦å¶å­ä¹‹å’Œ](https://leetcode.cn/problems/sum-of-left-leaves/)

- å·¦å¶å­ï¼šå¶å­ç»“ç‚¹ï¼Œæ¥è‡ªå·¦è¾¹
- åˆ¤æ–­å·¦è¾¹ï¼šè¦åœ¨å¤„ç†ä¸Šå†Œçš„æ—¶å€™è€ƒè™‘

### BFS

### é€’å½’

# æ ‘æ“ä½œ

## âœ… [226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/)

- æ”¹å˜æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³æŒ‡é’ˆ

```java
private void swap(TreeNode root) {
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
}
```

### BFS

- ä»é¡¶åˆ°åº•ï¼Œå¯¹äºæ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½äº¤æ¢å…¶å·¦å³èŠ‚ç‚¹

### DFS-é€’å½’/è¿­ä»£

- éšä¾¿é€‰æ‹©ä¸€ç§éå†é¡ºåºéƒ½å¯

## âœ… [617. åˆå¹¶äºŒå‰æ ‘](https://leetcode.cn/problems/merge-two-binary-trees/)

### é€’å½’

```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null) {
        return null;
    }

    if (root1 == null || root2 == null) {
        return root1 == null ? root2 : root1;
    }

    TreeNode root = new TreeNode(root1.val + root2.val);
    root.left = mergeTrees(root1.left, root2.left);
    root.right = mergeTrees(root1.right, root2.right);
    return root;
}
```

## ğŸ˜ [623. åœ¨äºŒå‰æ ‘ä¸­å¢åŠ ä¸€è¡Œ](https://leetcode.cn/problems/add-one-row-to-tree/)

- å…ˆæ‰¾åˆ°ç¬¬K-1å±‚ï¼Œæ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œå¢åŠ å¤„ç†

### BFS

```java
public TreeNode addOneRow(TreeNode root, int val, int depth) {
      // è§„åˆ™ï¼šå¦‚æœç¬¬ä¸€å±‚ï¼ŒåŸæ¥rootä½œä¸ºå·¦å­æ ‘
      if (depth == 1) {
          TreeNode inserted = new TreeNode(val);
          inserted.left = root;
          return inserted;
      }

      /*å¦‚æœä¸æ˜¯ç¬¬ä¸€å±‚çš„é€»è¾‘*/
      List<TreeNode> kNodes = getKNodes(root, depth - 1);
      for (TreeNode node : kNodes) {
          addChild(node, val);
      }
      return root;
  }

  /*rootæ ¹ç»“ç‚¹çš„ä¸º1*/
  private List<TreeNode> getKNodes(TreeNode root, int k) {
      List<TreeNode> result = new ArrayList<>();
      if (root == null) {
          return result;
      }

      Queue<TreeNode> queue = new LinkedList<>();
      queue.offer(root);
      int currentLayerSize = 1;
      int depth = 1;

      while (!queue.isEmpty()) {
          int nextLayerSize = 0;
          for (int i = 0; i < currentLayerSize; i++) {
              TreeNode poll = queue.poll();

              /*å¦‚æœæ˜¯ç¬¬Kå±‚ï¼Œé‚£ä¹ˆå°±å°è£…*/
              if (depth == k) {
                  result.add(poll);
              }

              if (poll.left != null) {
                  queue.offer(poll.left);
                  nextLayerSize++;
              }

              if (poll.right != null) {
                  queue.offer(poll.right);
                  nextLayerSize++;
              }
          }
          depth++;
          currentLayerSize = nextLayerSize;

          if (result.size() != 0) {
              return result;
          }
      }

      return result;
  }

  private void addChild(TreeNode node, int val) {
      /*å¤„ç†left*/
      TreeNode insertedLeft = new TreeNode(val);
      TreeNode prevLeft = node.left;
      node.left = insertedLeft;
      insertedLeft.left = prevLeft;

      /*å¤„ç†right*/
      TreeNode insertedRight = new TreeNode(val);
      TreeNode prevRight = node.right;
      node.right = insertedRight;
      insertedRight.right = prevRight;
  }
```

### DFS-é€’å½’

```java
private List<TreeNode> kNodes = new ArrayList<>();

public TreeNode addOneRow(TreeNode root, int val, int depth) {
    // è§„åˆ™ï¼šå¦‚æœç¬¬ä¸€å±‚ï¼ŒåŸæ¥rootä½œä¸ºå·¦å­æ ‘
    if (depth == 1) {
        TreeNode inserted = new TreeNode(val);
        inserted.left = root;
        return inserted;
    }

    bfsRecur(root, val, depth - 1);
    for (TreeNode node : kNodes) {
        addChild(node, val);
    }
    return root;

}

private void bfsRecur(TreeNode root, int val, int depth) {
    if (root == null) {
        return;
    }

    if (depth == 1) {
        kNodes.add(root);
    }
    bfsRecur(root.left, val, depth - 1);
    bfsRecur(root.right, val, depth - 1);
}

private void addChild(TreeNode node, int val) {
    /*å¤„ç†left*/
    TreeNode insertedLeft = new TreeNode(val);
    TreeNode prevLeft = node.left;
    node.left = insertedLeft;
    insertedLeft.left = prevLeft;

    /*å¤„ç†right*/
    TreeNode insertedRight = new TreeNode(val);
    TreeNode prevRight = node.right;
    node.right = insertedRight;
    insertedRight.right = prevRight;
}
```

## ğŸ˜ [116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

- æ»¡äºŒå‰æ ‘

### BFS-é˜Ÿåˆ—

- å±‚åºéå†çš„æ—¶å€™ï¼Œåˆ©ç”¨prevæŒ‡é’ˆï¼Œæ¥å»ºç«‹nextæŒ‡é’ˆ
- é˜Ÿåˆ—æœ‰ä½¿ç”¨åˆ°é¢å¤–ç©ºé—´

```java
public Node connect(Node root) {
    Queue<Node> queue = new LinkedList<>();
    if (root == null) {
        return root;
    }

    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        int nextLayerSize = 0;
        Node prev = null;
        for (int i = 0; i < currentLayerSize; i++) {
            Node poll = queue.poll();
            if (prev != null) {
                prev.next = poll;
            }
            prev = poll;


            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }
            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        currentLayerSize = nextLayerSize;
    }
    return root;
}
```

### BFS-O1ç©ºé—´

- å¤„ç†ç¬¬N-1å±‚çš„æ—¶å€™ï¼ŒN-1å±‚çš„æŒ‡é’ˆå·²ç»å…¨éƒ¨è¿æ¥å¥½äº†ï¼Œéå†æ˜¯ä¸ºäº†ç»™ç¬¬Nå±‚åŠ æŒ‡é’ˆ
- å¤„ç†ç¬¬N-1å±‚çš„æ—¶å€™ï¼Œæ˜¯åˆ©ç”¨æŒ‡é’ˆç§»åŠ¨ï¼Œæ‰€ä»¥ä¸éœ€è¦é˜Ÿåˆ—

![image-20240113164031984](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240113164031984.png)

```java
public Node connect(Node root) {
    if (root == null) {
        return root;
    }
    Node leftMost = root; // ä»ä¸Šå‘ä¸‹ç§»åŠ¨
    Node cur = leftMost;// ä»å·¦å¾€å³ç§»åŠ¨

    while (leftMost.left != null) { // ä»ä¸Šåˆ°ä¸‹å¤„ç†é€»è¾‘
        // åŒå±‚å¤„ç†é€»è¾‘
        while (cur != null) {
            cur.left.next = cur.right;      // å½“å‰ç»“ç‚¹å·¦å³è¿èµ·æ¥
            if (cur.next != null) {
                cur.right.next = cur.next.left; // å½“å‰ç»“ç‚¹çš„å³å’Œä¸‹ä¸€ä¸ªç»“ç‚¹çš„å·¦
            }
            cur = cur.next;
        }
        leftMost = leftMost.left;
        cur = leftMost;
    }

    return root;
}
```

## ğŸ˜ [117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

- æ™®é€šäºŒå‰æ ‘

### BFS-é˜Ÿåˆ—

- ä»£ç ç•¥ï¼ŒåŒä¸Š

### BFS-O1ç©ºé—´

- ä¸‹ä¸€å±‚çš„leftMostï¼Œéœ€è¦åœ¨ä¸²è”ä¸‹ä¸€å±‚çš„æ—¶å€™æ‰èƒ½ç¡®å®š

```java
public Node connect(Node root) {
    Node leftMost = root;
    Node cur = leftMost;
    while (leftMost != null) {
        leftMost = connectNextLayer(cur);
        cur = leftMost;
    }
    return root;
}

/*æ ¹æ®N-1å±‚çš„æŒ‡é’ˆï¼Œå»ä¸²è”Nå±‚çš„æŒ‡é’ˆï¼Œå¹¶è¿”å›ç¬¬Nå±‚çš„å¤´ç»“ç‚¹*/
private Node connectNextLayer(Node cur) {
    Node sentinel = new Node(-999);
    Node p = sentinel;

    while (cur != null) {
        if (cur.left != null) {
            p.next = cur.left;
            p = p.next;
        }

        if (cur.right != null) {
            p.next = cur.right;
            p = p.next;
        }
        cur = cur.next;
    }
    return sentinel.next;
}
```

# æŸ¥æ‰¾

## ğŸ˜ [236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

```bash
# å…¬å…±ç¥–å…ˆæƒ…å†µ
- på’Œqåˆ†åˆ«åœ¨ nodeçš„å·¦å³å­æ ‘ä¸­ï¼Œ nodeå°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆ(ä»åº•åˆ°é¡¶æœæŸ¥)
- p=nodeï¼Œ ä¸” q åœ¨ nodeçš„å·¦æˆ–å³å­æ ‘ä¸­ï¼›
- q=nodeï¼Œ ä¸” p åœ¨ nodeçš„å·¦æˆ–å³å­æ ‘ä¸­ï¼›
```

![image-20240117102802328](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240117102802328.png)

### é€’å½’-TODO

- é€’å½’æ‰æ˜¯ç‹é“

### ååº(è¿­ä»£) + Hash

- ä¸ç”¨è€ƒè™‘ä¸Šé¢çš„å…³ç³»
- nodeçš„valä¸é‡å¤ï¼Œæ‰¾åˆ°på’Œqæ‰€åœ¨çš„è·¯å¾„ (æ ¹èŠ‚ç‚¹-> p/q)
- ç„¶åç”¨hashæ¥æŸ¥æ‰¾ä¸¤æ¡è·¯å¾„çš„äº¤ç‚¹(ä»åº•å‘ä¸Š)ï¼Œç¬¬ä¸€æ¬¡çš„äº¤ç‚¹ï¼Œå°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆ

```bash
# HashSet
    # key:    hash.val
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    LinkedList<TreeNode> pPath = getTargetPath(root, p);
    LinkedList<TreeNode> qPath = getTargetPath(root, q);
    Set<Integer> hash = new HashSet<>();

    while (!pPath.isEmpty()) {
        TreeNode pop = pPath.pop();
        hash.add(pop.val); // ä»ä¸‹è€Œä¸Š
    }

    while (!qPath.isEmpty()) {
        TreeNode pop = qPath.pop();// ä»ä¸‹è€Œä¸Š
        if (!hash.add(pop.val)) {
            return pop;
        }
    }
    return null;
}

private LinkedList<TreeNode> getTargetPath(TreeNode root, TreeNode target) {
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = paths.peek();
            // åˆ¤æ–­æ˜¯å¦ä¸ºtargetç»“ç‚¹
            if (peek.val == target.val) {
                return paths;
            }

            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = paths.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return paths;
}
```

## ğŸ˜ [863. äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸º K çš„ç»“ç‚¹](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/)

- nodeçš„å€¼ä¸é‡å¤

### Hash + é€’å½’

```java
/* key:   childçš„val
 * valueï¼šparentçš„TreeNode
 * ä»è€Œå¯ä»¥é€šè¿‡childæ‰¾åˆ°parent*/
private Map<Integer, TreeNode> cache = new HashMap<>();

private List<Integer> result = new ArrayList<>();

/*targetæ˜¯å…¶ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”ä¸æ˜¯å­¤ç«‹çš„ç»“ç‚¹*/
public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
    if (root == null) {
        return result;
    }

    buildParent(root);
    findKNode(target, null, k);
    return result;
}

/*DFSä¸€æ¬¡ï¼Œå»ºç«‹çˆ¶å­å…³ç³»*/
public void buildParent(TreeNode root) {
    if (root == null) {
        return;
    }

    if (root.left != null) {
        cache.put(root.left.val, root);
        buildParent(root.left);
    }
    if (root.right != null) {
        cache.put(root.right.val, root);
        buildParent(root.right);
    }
}

/*targetä¸æ˜¯å­¤ç«‹çš„ç»“ç‚¹, fromä»£è¡¨å½“å‰å¤„ç†çš„ç»“ç‚¹*/
private void findKNode(TreeNode target, TreeNode from, int k) {
    if (target == null) {
        return;
    }
    if (k == 0) {
        result.add(target.val);
        return;
    }


    /*å·¦å³å­©å­ä¸­æ‰¾*/
    if (target.left != from) {
        findKNode(target.left, target, k - 1);
    }

    if (target.right != from) {
        findKNode(target.right, target, k - 1);
    }

    /*å‘ä¸Šæ‰¾:å¾€ä¸Šç¿»çš„æ—¶å€™ï¼Œåˆä¼šå»æ‰¾çˆ¶ç»“ç‚¹çš„å·¦å³ç»“ç‚¹*/
    TreeNode parent = cache.get(target.val);
    if (parent != from) {
        findKNode(parent, target, k - 1);
    }
}
```

# æ ‘æ„å»º

## ğŸ˜ [114. å‰åºå±•å¼€ä¸ºå•é“¾è¡¨](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

- å‰åºéå†ï¼Œä¿å­˜å¥½æ¯ä¸ªèŠ‚ç‚¹ï¼Œç„¶åå¼€å§‹æ”¹å˜æŒ‡é’ˆæ–¹å‘

### å‰åº + é€’å½’

- ç¬¬ä¸€æ¬¡éå†å‰åºå±•å¼€ï¼ŒListä¿å­˜æ¯ä¸ªç»“ç‚¹
- å¤„ç†Listä¸­çš„ç»“ç‚¹

```java
private List<TreeNode> preorder = new ArrayList<>();

public void flatten(TreeNode root) {
    if (root == null) {
        return;
    }
    fill(root);

    TreeNode prev = null;
    for (int i = 0; i < preorder.size(); i++) {
        TreeNode cur = preorder.get(i);

        if (prev != null) {
            prev.left = null;
            prev.right = cur;
        }
        prev = cur;
    }
}

private void fill(TreeNode root) {
    if (root == null) {
        return;
    }
    preorder.add(root);
    fill(root.left);
    fill(root.right);
}
```

### O1-TODO

## ğŸ˜¡[105. å‰åºä¸ä¸­åºæ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

- å‰åºéå†çš„ç»“æœï¼š[ æ ¹èŠ‚ç‚¹, [å·¦å­æ ‘çš„å‰åºéå†ç»“æœ], [å³å­æ ‘çš„å‰åºéå†ç»“æœ] ]
- ä¸­åºéå†çš„ç»“æœï¼š[ [å·¦å­æ ‘çš„ä¸­åºéå†ç»“æœ], æ ¹èŠ‚ç‚¹, [å³å­æ ‘çš„ä¸­åºéå†ç»“æœ] ]

#### é€’å½’  + æ•°ç»„æ‹·è´

![image-20231231102737796](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231231102737796.png)

```bash
# å‰åºï¼š [3,ï¼ˆ6,2ï¼‰,ï¼ˆ1,7,4ï¼‰]
# ä¸­åºï¼š[ï¼ˆ2,6ï¼‰,3,ï¼ˆ7,1,4ï¼‰]

# 1. æ ¹ç»“ç‚¹
- æ ¹ç»“ç‚¹ï¼š å‰åºçš„ç¬¬ä¸€ä¸ªï¼š3
- æ ¹æ®æ ¹ç»“ç‚¹ï¼Œåœ¨ä¸­åºä¸­æ‰¾ï¼Œå·¦è¾¹çš„æ˜¯å·¦å­æ ‘ï¼Œå³è¾¹çš„æ˜¯å³å­æ ‘

# 2. å‰åº[6,2]æ˜¯å·¦å­æ ‘ï¼Œ [1,7,4]æ˜¯å³å­æ ‘
```

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    /*ç»ˆæ­¢æ¡ä»¶*/
    if (preorder.length == 0) {
        return null;
    }

    if (preorder.length == 1) {
        return new TreeNode(preorder[0]);
    }

    TreeNode root = new TreeNode(preorder[0]);
    int length = preorder.length;
    /*å¾—åˆ°ä¸­åºçš„rootç»“ç‚¹çš„index*/
    int targetIndexInOrder = 0;
    for (int i = 0; i < inorder.length; i++) {
        if (root.val == inorder[i]) {
            targetIndexInOrder = i;
            break;
        }
    }

    /*ç´¢å¼•çš„å¼€å§‹å’Œç»“æŸä½ç½® [):*/

    // ä¸¤ä¸ªæ•°ç»„é•¿åº¦è¦ä¸€æ ·
    int[] leftNextInOrder = Arrays.copyOfRange(inorder, 0, targetIndexInOrder);
    int[] leftNextPreOrder = Arrays.copyOfRange(preorder, 1, targetIndexInOrder + 1); 
    root.left = buildTree(leftNextPreOrder, leftNextInOrder);

    //ä¸¤ä¸ªæ•°ç»„é•¿åº¦è¦ä¸€æ · 
    int[] rightNextInOrder = Arrays.copyOfRange(inorder, targetIndexInOrder + 1, length);
    int[] rightNextPreOrder = Arrays.copyOfRange(preorder, targetIndexInOrder + 1, length);
    root.right = buildTree(rightNextPreOrder, rightNextInOrder);
    return root;
}
```
