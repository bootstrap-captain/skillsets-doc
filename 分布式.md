# 分布式锁

## 1. 理念

### 1.1 Java锁

- 集群模式下，synchronized只能保证单个JVM内部的线程互斥，不能保证跨JVM的互斥

![image-20230329155717221](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329155717221.png)

### 1.2 分布式锁

- 提高锁的作用域

```bash
# 分布式锁特点
1. 多进程可见：     必须多个jvm都可访问到该锁资源
2. 互斥：          锁资源必须是互斥
3. 高可用：        锁的稳定性
4. 高性能：        加锁本来就会降低系统性能，如何保证
5. 安全性：        锁假如无法释放怎么办
```

![image-20230329160134829](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329160134829.png)

## 2. Redis分布式锁

### 2.1 基础版本

- Redis的工作线程是单线程访问，保证一定只有一个线程来获取锁

```bash
# 场景一： 假如锁释放失败怎么办？
1. 获取:     SETNX k v
2. 执行业务
3. 释放锁    DEL k

# 场景二：
1. 获取锁，并添加过期时间    SET K V EX 10 NX
2. 执行业务
3. 释放锁
```

```java
/***
 * 基础版本的Redis分布式锁
 */
public class RedisBasicLock {
    private static final String LOCK_NAME = "nike:order:2022-09-01";
    private static final String LOCK_VALUE = "1";
    private static long keyTTLSeconds = 5;

    /**
     * 方式一：假如锁释放失败，则该锁永远无法释放
     */
    public static void firstLock() {
        Jedis jedis = getJedis();
        long result = jedis.setnx(LOCK_NAME, LOCK_VALUE);
        if (1 == result) {
            business();
        } else {
            System.out.println("get lock failure");
        }
        jedis.del(LOCK_NAME);
    }

    /**
     * 方式二： 超时机制保证锁一定能够释放
     */
    public static void secondLock() {
        Jedis jedis = getJedis();
        String result = jedis.set(LOCK_NAME, LOCK_VALUE, SetParams.setParams().nx().ex(keyTTLSeconds));
        if ("OK".equalsIgnoreCase(result)) {
            business();
        } else {
            System.out.println("get lock failure");
        }
        jedis.del(LOCK_NAME);
    }

    public static void business() {
        System.out.println(Thread.currentThread().getName() + " executing business");
    }

    public static void main(String[] args) {
        new Thread(() -> RedisBasicLock.firstLock()).start();
        new Thread(() -> RedisBasicLock.firstLock()).start();
    }
}
```

### 2.2 增强版本

- 上面分布式锁存在的问题： 误删，删已失效

![image-20230329160706259](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329160706259.png)

```bash
# 解决方法一：设置超时时间远大于业务执行时间，但是会带来性能问题

# 解决方法二：删除锁的时候要判断，是不是自己的，如果是再删除    UUID

1. 其中key可以用业务名称来表示
2. value 用uuid加线程标识
   2.1 删除锁时，先通过value来判断锁是不是自己线程的
   2.2 如果是，则删除，如果不是，就不要删除
```

```java
package com.erick.lock;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.params.SetParams;

import java.util.UUID;

import static com.erick.redis.JedisConnectionFactory.getJedis;

public class RedisSecondLock {
    private static final String LOCK_NAME = "nike:order:2022-09-01";

    private static long keyTTLSeconds = 5;

    private static String getLockValue() {
        return Thread.currentThread().getId() + UUID.randomUUID().toString();
    }

    private static void executeBusiness() {
        System.out.println("Business execution.....");
    }

    private static void firstMethod(String lockKey, String lockValue) {
        Jedis redis = getJedis();
        String result = redis.set(lockKey, lockValue, SetParams.setParams().nx().ex(keyTTLSeconds));

        if ("OK".equalsIgnoreCase(result)) {
            executeBusiness();
            String presentValue = redis.get(lockKey);
            /*判断是否是自己的，是自己的再删除*/
            if (lockValue.equalsIgnoreCase(presentValue)) {
                redis.del(lockKey);
                System.out.println("lock deleted");
            }
        } else {
            System.out.println("Can not get lock");
        }
    }

    public static void main(String[] args) {
        new Thread(() -> firstMethod(LOCK_NAME, getLockValue())).start();
    }
}
```

### 2.3 LUA脚本

- 上面方案存在的问题：依然可能存在原子性问题
- 判断锁是否能释放，和锁真正释放的代码中间，假如存在full gc，那么就会依然出现问题
- 判断锁是否该释放和释放锁，应该做成一个原子性动作， 但是redis的事务机制不是强一致性

![image-20230329161221837](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329161221837.png)

- Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令的原子性

```bash
# 1. Redis内部函数
redis.call('命令名称','key','其他参数', ......)

# 2. 执行脚本 EVAL "redis.call()"
# 无参数， 0代表脚本的key的参数个数
EVAL "return redis.call('set','name','erick')" 0

# 3. 带参数
EVAL "return redis.call('set',KEYS[1],ARGV[1])" 1 age 20
KEYS[1]:  redis的key值个数
ARGV[1]:  redis的value的值个数
1:        具体包含几个key
age：     实际传递的key值
20:       实际传递的value值
```

- 获取流程

```lua
-- 获取锁中的线程标识，动态传递参数
local lockValue = redis.call('get',KEYS[1])

-- 比较线程标示与锁中的是否一致
if (ARGV[1] == lockValue) then
   -- 释放锁
    redis.call('del',KEYS[1])
    return 1
else
    return 0
end
```

```java
package com.erick.lock;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.params.SetParams;

import java.util.Collections;
import java.util.UUID;

import static com.erick.redis.JedisConnectionFactory.getJedis;

public class RedisLuaLock {
    private static final String LOCK_NAME = "nike:order:2022-09-01";

    private static long keyTTLSeconds = 5;

    private static String getLockValue() {
        return Thread.currentThread().getId() + UUID.randomUUID().toString();
    }

    private static void executeBusiness() {
        System.out.println("Business execution.....");
    }

    private static void firstMethod(String lockKey, String lockValue) {
        Jedis redis = getJedis();
        String result = redis.set(lockKey, lockValue, SetParams.setParams().nx().ex(keyTTLSeconds));

        if ("OK".equalsIgnoreCase(result)) {
            System.out.println("获取锁成功");
            executeBusiness();
            if (deleteLockWithLua(lockKey, lockValue)) {
                System.out.println("释放锁成功");
            }
        }
    }

    private static boolean deleteLockWithLua(String lockKey, String lockValue) {
        String luaScript = """
                local keyName = redis.call('get',KEYS[1])
                if (ARGV[1] == keyName) then
                    redis.call('del',KEYS[1])
                    return 1
                else
                    return 0
                end       
                """;
        Jedis jedis = getJedis();
        /*加载脚本*/
        String script = jedis.scriptLoad(luaScript);
        /*执行脚本*/
        Object result = jedis.evalsha(script, Collections.singletonList(lockKey), Collections.singletonList(lockValue));
        return result.equals(1L);
    }

    public static void main(String[] args) {
        new Thread(() -> firstMethod(LOCK_NAME, getLockValue())).start();
    }
}
```

### 2.4 存在的问题

- 某些业务场景，需要对锁有更高的要求
- 极端情况下出现的问题

![image-20230329161517201](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329161517201.png)

## 3.Redisson

- 一个用来进行分布式锁的工具jar

```java
package com.erick.redisson;

import org.redisson.Redisson;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

import java.util.concurrent.TimeUnit;

public class RedissonDemo {

    private static final String LOCK_KEY = "nike:order:2022.08.14";

    private static RedissonClient getRedissonClient() {
        Config config = new Config();
        /*单节点*/
        config.useSingleServer().setAddress("redis://60.205.229.31:6381");
        RedissonClient redissonClient = Redisson.create(config);
        return redissonClient;
    }

    public static void main(String[] args) {
        new Thread(() -> executeWithLock()).start();
        new Thread(() -> executeWithLock()).start();
    }

    /*基本使用*/
    public static void executeWithLock() {
        RedissonClient redissonClient = getRedissonClient();
        /*获取锁： RLock extends Lock*/
        RLock lock = redissonClient.getLock(LOCK_KEY);

        /**
         *  可重入锁：
         *    参数一： waitTime：默认为-1，失败了立刻返回
         *    参数二： leaseTime: 默认锁释放时间为30s*/
        if (lock.tryLock()) {
            System.out.println(Thread.currentThread().getName() + "获取到锁");
            try {
                business();
            } catch (Exception e) {
                System.out.println("业务执行失败");
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("获取锁失败");
        }
    }

    public void executeWithLockRetry() {
        RedissonClient redissonClient = getRedissonClient();
        RLock lock = redissonClient.getLock(LOCK_KEY);
        /**
         * 参数一： 最长等待时间，超时则不再等待， 会触发重试等待
         * 参数二： 锁自动释放时间
         * 参数三： 时间单位
         */
        boolean hasLock = false;
        try {
            hasLock = lock.tryLock(6, 20, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        if (hasLock) {
            try {
                business();
            } catch (Exception e) {
                System.out.println("业务发生异常");
            } finally {
                lock.unlock();
            }
        }
    }

    private static void business() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println("执行业务");
    }
}
```

### 3.1 可重入

- Redission的锁具有可重入性

#### 不可重入锁

![image-20230329162251309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329162251309.png)

#### 锁重入原理

- 存储的键值对用Hash结构来保存
- 为了保证多条命令的原子性，必须采取lua脚本来做

![image-20230329162423220](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329162423220.png)

#### LUA脚本

![image-20230329163131401](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329163131401.png)

![image-20230329163157062](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329163157062.png)

### 3.2 重试机制

- 通过等待时间结合，发布以及订阅模式来实现
- 不会立即触发重试机制，而是订阅当前锁的使用者发布的消息

### 3.3 锁超时释放

- 业务执行期间，不断有定时任务去更新过期时间
- 业务执行完毕后，取消定时任务

### 3.4 主从一致->联锁

- 主从一致性问题：由于主节点宕机，但是主节点的数据还未向从节点传输，引发的锁失效问题

![image-20230329163359012](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329163359012.png)

- 解决方案：设立多个redis作为主节点
- 只有每个都获取成功的时候，才会去执行。只要有一组正常的主从，就可以保证锁不会失效

![image-20230329163706012](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230329163706012.png)

```java
package com.erick.redis;

import org.redisson.Redisson;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

import java.util.concurrent.TimeUnit;

public class Test04 {
    public static void main(String[] args) {
        businessWithLock();
    }

    private static void businessWithLock() {
        String lockKey = "BUSINESS";
        RedissonClient firstClient = redissonClient01();
        RedissonClient secondClient = redissonClient02();
        RedissonClient thirdClient = redissonClient03();

        RLock firstLock = firstClient.getLock(lockKey);
        RLock secondLock = secondClient.getLock(lockKey);
        RLock thirdLock = thirdClient.getLock(lockKey);

        /*获取到多把锁*/
        RLock multiLock = firstClient.getMultiLock(firstLock, secondLock, thirdLock);

        boolean hasLock = multiLock.tryLock();
        try{
            if (hasLock) {
                business();
            } else {
                System.out.println("未获取到锁，业务没有执行");
            }
        }finally {
            multiLock.unlock();
        }
    }

    private static void business() {
        System.out.println("执行业务");
        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /*Redis的配置类*/
    private static RedissonClient redissonClient01() {
        Config config = new Config();
        config.useSingleServer().setAddress("redis://60.205.229.31:6379");
        return Redisson.create(config);
    }

    private static RedissonClient redissonClient02() {
        Config config = new Config();
        config.useSingleServer().setAddress("redis://60.205.229.31:6380");
        return Redisson.create(config);
    }

    private static RedissonClient redissonClient03() {
        Config config = new Config();
        config.useSingleServer().setAddress("redis://60.205.229.31:6381");
        return Redisson.create(config);
    }
}

```

# 