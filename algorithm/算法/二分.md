# ç®—æ³•æ€è·¯

- é’ˆå¯¹æœ‰åºæ•°ç»„ï¼Œæä¾›çš„ä¸€ç§å¿«é€ŸæŸ¥æ‰¾çš„æœç´¢ç®—æ³•

## æ— é‡å¤å…ƒç´ 

### âœ… [704. äºŒåˆ†æŸ¥æ‰¾](https://leetcode.cn/problems/binary-search/)

- æŸ¥æ‰¾åˆ°åˆ™è¿”å›ç´¢å¼•ï¼ŒæŸ¥æ‰¾ä¸åˆ°åˆ™è¿”å›-1

#### è¿­ä»£-åŸºç¡€ç‰ˆ

```bash
# æ€è·¯
- å¦‚æœleftå’Œrighté‡å ï¼Œä¸”å½“å‰ç´¢å¼•å€¼ç­‰äºtargetï¼Œè¿™ä¸ªæ—¶å€™å°±æ˜¯è¦å¾ªç¯ä¸­ left=right å‘æŒ¥ä½œç”¨
```

![image-20240126120715628](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240126120715628.png)

```java
public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int middle = (left + right) / 2;
            if (nums[middle] > target) {
                right = middle - 1;
            } else if (nums[middle] < target) {
                left = middle + 1;
            } else {
                return middle;
            }
        }

        return -1;
}
```

#### è¿­ä»£-æ”¹è¿›ç‰ˆ

- å³æŒ‡é’ˆä¸€å®šä¸æ˜¯æŸ¥æ‰¾ç›®æ ‡

![image-20240129104513545](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240129104513545.png)

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length;
    while (left < right) {
        int middle = (left + right) / 2;
        if (nums[middle] > target) {
            right = middle;
        } else if (nums[middle] < target) {
            left = middle + 1;
        } else {
            return middle;
        }
    }
    return -1;
}
```

#### è¿­ä»£-å¹³è¡¡ç‰ˆ

- ä¸Šé¢ä¸¤ç§å®ç°ï¼Œå‡å¦‚å¾…æŸ¥æ‰¾å…ƒç´ ä¸å­˜åœ¨ï¼Œä¸”ä½äºæœ€å·¦è¾¹æˆ–è€…æœ€å³è¾¹ï¼ŒæŸ¥æ‰¾æœ€å·¦è¾¹æˆ–è€…æœ€å³è¾¹æ—¶ï¼Œwhileå¾ªç¯ä¸­ï¼Œè¿›è¡Œåˆ¤æ–­çš„æ¬¡æ•°ä¸ä¸€æ ·

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length;
    /*åªç®¡ç¼©å°è¾¹ç•Œ*/
    while ((right - left) > 1) {
        int middle = (left + right) / 2;
        if (target < nums[middle]) {
            right = middle;
        } else {
            left = middle;
        }
    }

    /*å‰©ä¸‹ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå’Œtargetè¿›è¡Œæ¯”è¾ƒ*/
    if (nums[left] == target) {
        return left;
    } else {
        return -1;
    }
}
```

### âœ… [35. æœç´¢æ’å…¥ä½ç½®](https://leetcode.cn/problems/search-insert-position/)

- æ’åºæ•°ç»„å’Œç›®æ ‡å€¼ï¼Œåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡å€¼ï¼Œå¹¶è¿”å›å…¶ç´¢å¼•ã€‚
- å¦‚æœç›®æ ‡å€¼ä¸å­˜åœ¨äºæ•°ç»„ä¸­ï¼Œè¿”å›å®ƒå°†ä¼šè¢«æŒ‰é¡ºåºæ’å…¥çš„ä½ç½®
- æ— é‡å¤å…ƒç´ 

```java
public int searchInsert(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        if (target < nums[middle]) {
            right = middle - 1;
        } else if (nums[middle] < target) {
            left = middle + 1;
        } else {
            return middle;
        }
    }

    return left;
}
```

## æœ‰é‡å¤å…ƒç´ 

- å½“æœ‰é‡å¤å…ƒç´ æ—¶ï¼Œéœ€è¦è¿”å›æœ€å·¦è¾¹æˆ–è€…æœ€å³è¾¹çš„æ•°æ®

### LeftMost 

```java
private int leftMost(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    int candidate = -1;
    while (left <= right) {
        int middle = (left + right) / 2;
        if (target < nums[middle]) {
            right = middle - 1;
        } else if (nums[middle] < target) {
            left = middle + 1;
        } else {
            candidate = middle;
            right = middle - 1; // ç»§ç»­ç§»åŠ¨å³æŒ‡é’ˆ
        }
    }

    return candidate;
}
```

### RightMost

```java
private int rightMost(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    int candidate = -1;
    while (left <= right) {
        int middle = (left + right) / 2;
        if (target < nums[middle]) {
            right = middle - 1;
        } else if (nums[middle] < target) {
            left = middle + 1;
        } else {
            candidate = middle;
            left = middle + 1; // ç»§ç»­ç§»åŠ¨å·¦æŒ‡é’ˆ
        }
    }

    return candidate;
}
```



### ğŸ˜ [34. å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```java
public int[] searchRange(int[] nums, int target) {
    int[] result = new int[2];
    result[0] = leftMost(nums, target);
    result[1] = rightMost(nums, target);
    return result;
}
```

### âœ… [LCR 172. ç»Ÿè®¡ç›®æ ‡æˆç»©çš„å‡ºç°æ¬¡æ•°](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

```java
public int countTarget(int[] scores, int target) {
    int result = 0;
    int leftMost = leftMost(scores, target);
    int rightMost = rightMost(scores, target);

    if (leftMost != -1) {
        result = rightMost - leftMost + 1;
    }
    return result;
}
```

### âœ… [744. å¯»æ‰¾æ¯”ç›®æ ‡å­—æ¯å¤§çš„æœ€å°å­—æ¯](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/)

```java
public char nextGreatestLetter(char[] letters, char target) {
    int candidate = rightMost(letters, target);
    if (candidate == letters.length - 1) {
        return letters[0];
    } else {
        return letters[candidate + 1];
    }
}

/*è¿”å›æœ€å³åŒ¹é…å…ƒç´ çš„ç´¢å¼•ï¼Œæˆ–è€…åº”è¯¥æ’å…¥çš„å…ƒç´ çš„ä¸Šä¸€ä¸ªç´¢å¼•*/
private int rightMost(char[] letters, char target) {
    int left = 0;
    int right = letters.length - 1;
    int candidate = -1;
    while (left <= right) {
        int middle = (left + right) / 2;
        if (target < letters[middle]) {
            right = middle - 1;
        } else if (letters[middle] < target) {
            left = middle + 1;
        } else {
            candidate = middle;
            left = middle + 1;
        }
    }

    if (candidate == -1) { // æ²¡æ‰¾åˆ°çš„æƒ…å†µï¼Œè¿”å›æ’å…¥ä½ç½®
        return left - 1;
    } else { // æ‰¾åˆ°çš„æƒ…å†µ
        return candidate;
    }
}
```

# LeetCode

- çœ‹åˆ°O[log(n)]çš„é¢˜ç›®ï¼Œç¬¬ä¸€æ—¶é—´è”æƒ³äºŒåˆ†æŸ¥æ‰¾

## çŸ©é˜µ

```bash
# å…ƒç´ 16çš„åæ ‡ï¼šarr[1][2], xå’Œyåˆšå¥½ç›¸å
1ï¼Œ   3ï¼Œ   5ï¼Œ   7
10ï¼Œ 11ï¼Œ   16ï¼Œ  20
23ï¼Œ 30ï¼Œ   34ï¼Œ  60
```

###  ğŸ˜ [74. æœç´¢äºŒç»´çŸ©é˜µ](https://leetcode.cn/problems/search-a-2d-matrix/)

- ä¸¤æ¬¡äºŒåˆ†ï¼Œå…ˆæ‰¾åˆ°å“ªä¸€åˆ—ï¼Œå†äºŒåˆ†æŸ¥æ‰¾è¯¥åˆ—

```bash
1ï¼Œ   3ï¼Œ   5ï¼Œ   7
10ï¼Œ 11ï¼Œ   16ï¼Œ  20
23ï¼Œ 30ï¼Œ   34ï¼Œ  60
```

```java
/*1. å…ˆåˆ—æœç´¢ç¡®å®šåœ¨å“ªä¸€è¡Œ
 * 2. å†åœ¨å¯¹åº”çš„è¡Œä¸­æœç´¢æ•°æ®*/
public boolean searchMatrix(int[][] matrix, int target) {
    int row = findTargetRowIndex(matrix, target);
    return findTarget(matrix[row], target);
}

/*å…ˆäºŒåˆ†æŸ¥æ‰¾åˆ°å“ªä¸€åˆ—, å¦‚æœtargetä¸å­˜åœ¨å¤´å…ƒç´ ä¸­ï¼Œåˆ™è¿”å›æ’å…¥ä½ç½®*/
private int findTargetRowIndex(int[][] matrix, int target) {
    int left = 0;
    int right = matrix.length - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        int ele = matrix[middle][0];

        if (ele < target) {
            left = middle + 1;
        } else if (ele > target) {
            right = middle - 1;
        } else {
            return middle;
        }
    }

    if (left == 0) {
        return left;
    } else {
        return left - 1;
    }
}

private boolean findTarget(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        if (arr[middle] < target) {
            left = middle + 1;
        } else if (arr[middle] > target) {
            right = middle - 1;
        } else {
            return true;
        }
    }
    return false;
}
```

### ğŸ˜ [240. æœç´¢äºŒç»´çŸ©é˜µ II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

```bash
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

#### äºŒåˆ†æŸ¥æ‰¾

- ç¬¬ä¸€æ¬¡äºŒåˆ†ï¼Œæ‰¾åˆ°è¦éå†çš„å¤šå°‘è¡Œ
- ç„¶åå¯¹æ¯ä¸€è¡Œè¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾

```bash
# æ—¶é—´å¤æ‚åº¦ï¼š O(m*log(n))
# ç©ºé—´å¤æ‚åº¦ï¼šO(1)
```

```java
/*1. å…ˆåˆ—æœç´¢ç¡®å®šåœ¨å“ªäº›è¡Œå¯èƒ½å­˜åœ¨ç»“æœ
 * 2. å†åœ¨å¯¹åº”çš„è¡Œä¸­æœç´¢æ•°æ®*/
public boolean searchMatrix(int[][] matrix, int target) {
    int targetRowIndex = findTargetRowIndex(matrix, target);
    for (int i = 0; i < targetRowIndex + 1; i++) {
        int[] row = matrix[i];
        boolean rowResult = findTarget(row, target);
        if (rowResult) {
            return true;
        }
    }
    return false;
}

/*å…ˆäºŒåˆ†æŸ¥æ‰¾åˆ°å“ªä¸€åˆ—, å¦‚æœtargetä¸å­˜åœ¨å¤´å…ƒç´ ä¸­ï¼Œåˆ™è¿”å›æ’å…¥ä½ç½®*/
private int findTargetRowIndex(int[][] matrix, int target) {
    int left = 0;
    int right = matrix.length - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        int ele = matrix[middle][0];

        if (ele < target) {
            left = middle + 1;
        } else if (ele > target) {
            right = middle - 1;
        } else {
            return middle;
        }
    }

    if (left == 0) {
        return left;
    } else {
        return left - 1;
    }
}

private boolean findTarget(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        if (arr[middle] < target) {
            left = middle + 1;
        } else if (arr[middle] > target) {
            right = middle - 1;
        } else {
            return true;
        }
    }
    return false;
}
```

#### Zå­—éå†

- ä»å³ä¸Šè§’å‡ºå‘ï¼Œåœ¨å·¦ä¸‹è§’ç»“æŸ

```java
public boolean searchMatrix111(int[][] matrix, int target) {
    int columNumber = 0;
    int rowNumber = matrix[columNumber].length - 1;

    while (columNumber < matrix.length && rowNumber >= 0) {
        int cur = matrix[columNumber][rowNumber];
        if (cur < target) { // ä¸‹ç§»
            columNumber++;
        } else if (cur > target) { // å·¦ç§»
            rowNumber--;
        } else {
            return true;
        }
    }
    return false;
}
```



## æ—‹è½¬æ’åºæ•°ç»„-æ— é‡å¤

### ğŸ˜ [153. å¯»æ‰¾æœ€å°å€¼](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

![image-20240205100153553](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240205100153553.png)

```java
public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int middle = (left + right) / 2;
        int prev = middle - 1;
        /*ç›®æ ‡å…ƒç´ */
        if (prev >= 0 && nums[prev] > nums[middle]) {
            return nums[middle];
        }

        // å’Œå“ªè¾¹çš„baseå€¼æ¯”è¾ƒï¼Œå°±ç”¨é‚£è¾¹çš„=
        if (nums[middle] >= nums[0]) {
            left = middle + 1;
        } else {
            right = middle - 1;
        }
    }
    return nums[0];
}
```

### ğŸ˜ [33. æœç´¢](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

- æ— é‡å¤å€¼
- å…ˆæ‰¾åˆ°æœ€å°å€¼ï¼Œä»è€Œå°†æ—‹è½¬æ’åºæ•°ç»„åˆ’åˆ†ä¸ºä¸¤ä¸ªæ’åºæ•°ç»„ï¼Œç„¶ååˆ†åˆ«åœ¨ä¸¤ä¸ªæ’åºæ•°ç»„ä¸­è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾

```java
  public int search(int[] nums, int target) {
      int minIndex = findMin(nums);
      int firstCandidate = findTarget(nums, target, 0, minIndex - 1);
      int secondCandidate = findTarget(nums, target, minIndex, nums.length - 1);

      if (firstCandidate != -1) {
          return firstCandidate;
      } else {
          return secondCandidate;
      }
  }

  // 1. å…ˆæ‰¾åˆ°æœ€å°å€¼ï¼Œä»è€Œåˆ’åˆ†ä¸ºä¸¤ä¸ªæ•°ç»„
  private int findMin(int[] nums) {
      int left = 0;
      int right = nums.length - 1;

      while (left <= right) {
          int middle = (left + right) / 2;
          int prev = middle - 1;
          /*ç›®æ ‡å…ƒç´ */
          if (prev >= 0 && nums[prev] > nums[middle]) {
              return middle;
          }

          // å’Œå“ªè¾¹çš„baseå€¼æ¯”è¾ƒï¼Œå°±ç”¨é‚£è¾¹çš„=
          if (nums[middle] >= nums[0]) {
              left = middle + 1;
          } else {
              right = middle - 1;
          }
      }
      return 0;
  }

 // å•ä¸ªæ•°ç»„ä¸­ï¼Œéƒ¨åˆ†æ•°æ®ä¸­æœæŸ¥ç›®æ ‡å€¼
  private int findTarget(int[] nums, int target, int left, int right) {
      while (left <= right) {
          int middle = (left + right) / 2;
          if (nums[middle] < target) {
              left = middle + 1;
          } else if (nums[middle] > target) {
              right = middle - 1;
          } else {
              return middle;
          }
      }
      return -1;
  }
```

## å±±è„‰æ•°ç»„

### ğŸ˜ [162. å¯»æ‰¾å³°å€¼](https://leetcode.cn/problems/find-peak-element/)

- å¯èƒ½å­˜åœ¨å¤šä¸ªå³°å€¼

```java
/*å¤„ç†è¾¹ç•Œå€¼*/
private long get(int[] arr, int idx) {
    if (idx < 0 || idx > arr.length - 1) {
        return Long.MIN_VALUE;
    } else {
        return arr[idx];
    }
}
```

#### è¿­ä»£çˆ¬å¡

- éšæœºä»æ•°ç»„ä¸­æŒ‘é€‰ä¸€ä¸ªç´¢å¼•ï¼Œæ¯”è¾ƒå‰åçš„å€¼

```bash
# æ—¶é—´å¤æ‚åº¦ï¼š  O(n)
# ç©ºé—´å¤æ‚åº¦ï¼š  O(1)
```

```java
public int findPeakElement(int[] nums) {
    // éšä¾¿åœ¨æ•°ç»„ä¸­æŒ‘ä¸€ä¸ªç´¢å¼•ä½ç½®
    int idx = (int) (Math.random() * nums.length);

    while (true) {
        long prev = get(nums, idx - 1);
        long cur = get(nums, idx);
        long next = get(nums, idx + 1);

        if (prev < cur && cur > next) { // å³°å€¼
            return idx;
        }

        if (prev < cur && cur < next) { // ä¸Šå¡ï¼Œ å³ç§»
            idx++;
        } else if (prev > cur && cur > next) { // ä¸‹å¡ï¼Œ å·¦ç§»
            idx--;
        } else if (prev > cur && next > cur) { // å³°è°·ï¼Œè§„å®šå³ç§»ï¼Œä¹Ÿå¯ä»¥å·¦ç§»
            idx++;
        }
    }
}
```

#### äºŒåˆ†çˆ¬å¡

- é€‰å–ä¸­é—´ç‚¹ä½œä¸ºæœç´¢ä½ç½®

```java
public int findPeakElement(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        long prev = get(nums, middle - 1);
        long cur = get(nums, middle);
        long next = get(nums, middle + 1);

        if (prev < cur && cur > next) { // å³°å€¼
            return middle;
        }

        if (prev < cur && cur < next) { // ä¸Šå¡ï¼Œ å³ç§»
            left = middle + 1; // èˆå¼ƒå·¦è¾¹çš„æ•°æ®
        } else if (prev > cur && cur > next) { // ä¸‹å¡ï¼Œ å·¦ç§»
            right = middle - 1;
        } else if (prev > cur && next > cur) { // å³°è°·ï¼Œè§„å®šå³ç§»ï¼Œä¹Ÿå¯ä»¥å·¦ç§»
            left = middle + 1;
        }
    }
    return -1;
}
```

### ğŸ˜ [852. å±±è„‰æ•°ç»„çš„å³°é¡¶ç´¢å¼•](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

- å±±è„‰æ•°ç»„ï¼Œè¾¹ç•Œç”¨è´Ÿæ— ç©·æ¥ä»£æ›¿

```java
public int peakIndexInMountainArray(int[] arr) {
    int left = 0;
    int right = arr.length - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        long prev = get(arr, middle - 1);
        long cur = get(arr, middle);
        long next = get(arr, middle + 1);
        if (prev < cur && cur > next) {
            return middle;
        }

        if (prev < cur) { // å³ç§»
            left = middle + 1;
        } else if (prev > cur) { // å·¦ç§»
            right = middle - 1;
        }
    }
    return -1;
}

/*å¤„ç†è¾¹ç•Œå€¼*/
private long get(int[] arr, int idx) {
    if (idx < 0 || idx > arr.length - 1) {
        return Long.MIN_VALUE;
    } else {
        return arr[idx];
    }
}
```

