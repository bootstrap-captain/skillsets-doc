# äºŒå‰æœç´¢æ ‘

- å’ŒäºŒå‰æ ‘ä¸€æ ·ï¼Œä½†èŠ‚ç‚¹valueä¸é‡å¤
- æ‰€æœ‰èŠ‚ç‚¹ï¼Œvalueæ¯”å·¦å­æ ‘çš„valueå¤§ï¼Œæ¯”å³å­æ ‘çš„valueå°

![image-20231225154313795](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231225154313795.png)

## æŸ¥æ‰¾

### âœ… [700. æœç´¢](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

#### é€’å½’

```java
public TreeNode searchBST(TreeNode root, int val) {
    if (root == null) {
        return null;
    }

    if (root.val > val) {
        return searchBST(root.left, val);
    } else if (root.val < val) {
        return searchBST(root.right, val);
    } else {
        return root;
    }
}
```

#### è¿­ä»£

```java
public TreeNode searchBST(TreeNode root, int val) {
    TreeNode cur = root;
    while (cur != null) {
        if (cur.val < val) {
            cur = cur.right;
        } else if (cur.val > val) {
            cur = cur.left;
        } else {
            return cur;
        }
    }
    return cur;
}
```

### âœ… æœ€å°/æœ€å¤§

- æœ€å°æ˜¯æ‰¾å·¦è¾¹ï¼Œæœ€å¤§æ˜¯æ‰¾å³è¾¹

#### é€’å½’

```java
public TreeNode getMinRecur(TreeNode root) {
    if (root == null) {
        return null;
    }

    if (root.left == null) {
        return root;
    }

    TreeNode min = getMinRecur(root.left);
    return min;
}

public TreeNode getMaxRecur(TreeNode root) {
    if (root == null) {
        return null;
    }

    if (root.right == null) {
        return root;
    }
    TreeNode max = getMaxRecur(root.right);
    return max;
}
```

#### è¿­ä»£

```java
public TreeNode getMinIterator(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode cur = root;
    while (cur.left != null) {
        cur = cur.left;
    }
    return cur;
}

public TreeNode getMaxIterator(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode cur = root;
    while (cur.right != null) {
        cur = cur.right;
    }
    return cur;
}
```

### âœ… [530.æœ€å°ç»å¯¹å·®](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

- æœ€å°ç»å¯¹å·®ï¼Œä¸€å®šæ˜¯ç›¸é‚»çš„ä¸¤ä¸ªèŠ‚ç‚¹é—´ã€‚å¦‚æœä¸º1ï¼Œåˆ™å¯ä»¥ç›´æ¥ç»“æŸ
- ä¸­åºéå†ï¼Œå°±æ˜¯ç»“ç‚¹å€¼é€’å¢çš„è¿‡ç¨‹

#### ä¸­åº-è¿­ä»£

```java
public int getMinimumDifference(TreeNode root) {
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    TreeNode prev = null;
    int min = Integer.MAX_VALUE;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = paths.pop();
            // åˆ¤æ–­æ¡ä»¶
            if (prev != null) {
                int distance = pop.val - prev.val;
                if (distance == 1) {
                    return 1;
                }
                min = Math.min(min, distance);
            }
            prev = pop;

            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }
    return min;
}
```

#### ä¸­åº-é€’å½’

```java
private int min = Integer.MAX_VALUE;
private TreeNode prevNode = null;

public int getMinimumDifference(TreeNode root) {
    inorderRecur(root);
    return min;
}

private void inorderRecur(TreeNode root) {
    if (root == null) {
        return;
    }

    inorderRecur(root.left);

    if (prevNode != null) {
        min = Math.min((root.val - prevNode.val), min);
        if (min == 1) {
            return;
        }
    }
    prevNode = root;

    inorderRecur(root.right);
}
```

### âœ… [938. èŒƒå›´å’Œ](https://leetcode.cn/problems/range-sum-of-bst/)

#### ä¸­åº-é€’å½’

- åˆ©ç”¨ä¸­åºè§„åˆ™ï¼šè¾¾åˆ°ä¸Šç•Œæ—¶ï¼Œç«‹åˆ»é€€å‡º
- ä½†æ˜¯æ‰¾ä¸‹ç•Œï¼Œä»ç„¶éœ€è¦å¾ˆå¤šæ“ä½œ

```java
private int sum = 0;

public int rangeSumBST(TreeNode root, int low, int high) {
    rangeRecur(root, low, high);
    return sum;
}

private void rangeRecur(TreeNode root, int low, int high) {
    if (root == null) {
        return;
    }

    rangeSumBST(root.left, low, high);

    if (root.val > high) {
        return;
    }

    if (root.val >= low) {
        sum += root.val;
    }

    rangeSumBST(root.right, low, high);
}
```

#### ä¸­åº-è¿­ä»£

- åˆ©ç”¨ä¸­åºè§„åˆ™ï¼šè¾¾åˆ°ä¸Šç•Œæ—¶ï¼Œç«‹åˆ»é€€å‡º
- ä½†æ˜¯æ‰¾ä¸‹ç•Œï¼Œä»ç„¶éœ€è¦å¾ˆå¤šæ“ä½œ

```java
public int rangeSumBST(TreeNode root, int low, int high) {
  int sum = 0;
  LinkedList<TreeNode> paths = new LinkedList<>();
  TreeNode cur = root;
  while (cur != null || !paths.isEmpty()) {
      if (cur != null) {
          paths.push(cur);
          cur = cur.left;
      } else {
          TreeNode pop = paths.pop();
          // è¶…è¿‡æœ€å¤§å€¼ï¼Œç›´æ¥é€€å‡º
          if (pop.val > high) {
              break;
          }
          // æ¯”æœ€å°å€¼å¤§çš„æ‰å¤„ç†
          if (pop.val >= low) {
              sum += pop.val;
          }

          if (pop.right != null) {
              cur = pop.right;
          }
      }
  }
  return sum;
}
```

#### å‰ªæé€’å½’

- ä»é¡¶åˆ°åº•

```java
public int rangeSumBST(TreeNode root, int low, int high) {
    if (root == null) {
        return 0;
    }

    /*å¦‚æœè¾¾åˆ°ä¸Šç•Œï¼Œåˆ™æŠŠå³è¾¹çš„æå¶å‰ªæ‰*/
    if (root.val > high) {
        return rangeSumBST(root.left, low, high);
    }

    /*å¦‚æœè¾¾åˆ°ä¸‹ç•Œï¼Œåˆ™æŠŠå·¦è¾¹çš„æå¶å‰ªæ‰*/
    if (root.val < low) {
        return rangeSumBST(root.right, low, high);
    }

    return root.val +
            rangeSumBST(root.left, low, high) +
            rangeSumBST(root.right, low, high);
}
```

### ğŸ˜ [235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

- ä»æ ¹ç»“ç‚¹å¼€å§‹ï¼Œå¦‚æœä¸¤ä¸ªç»“ç‚¹åœ¨åŒä¾§ï¼Œåˆ™rootå‘é‚£è¾¹ç§»åŠ¨ï¼Œå¦åˆ™ç›´æ¥è¿”å›root

![image-20231225154313795](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231225154313795.png)

#### é€’å½’

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) {
        return null;
    }

    if (root.val < p.val && root.val < q.val) {
        return lowestCommonAncestor(root.right, p, q);
    }

    if (root.val > p.val && root.val > q.val) {
        return lowestCommonAncestor(root.left, p, q);
    }

    return root;
}
```

#### è¿­ä»£

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode ancestor = root;
    while (ancestor != null) {
        if (ancestor.val > p.val && ancestor.val > q.val) {
            ancestor = ancestor.left;
        } else if (ancestor.val < p.val && ancestor.val < q.val) {
            ancestor = ancestor.right;
        } else {
            break;
        }
    }
    return ancestor;
}
```

### ğŸ˜ [173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](https://leetcode.cn/problems/binary-search-tree-iterator/)

- ä¸è¦ç›´æ¥åœ¨æ„é€ å™¨é‡Œé¢æŠŠæ•°æ®ç›´æ¥è½¬æ¢æˆé›†åˆæˆ–è€…æ•°ç»„ï¼Œæ²¡å¿…è¦ä¸€ä¸‹å­å°±æŠŠäºŒå‰æœç´¢æ ‘å˜æˆé›†åˆäº†

#### ä¸­åº - è¿­ä»£

```java
class BSTIterator {
    private LinkedList<TreeNode> paths = new LinkedList<>();
    
    public BSTIterator(TreeNode root) {
        add(root);
    }

    public int next() {
        TreeNode pop = paths.pop();
        if (pop.right != null) {
            add(pop.right);
        }
        return pop.val;
    }

    public boolean hasNext() {
        return !paths.isEmpty();
    }

    private void add(TreeNode root) {
        TreeNode cur = root;
        while (cur != null) {
            paths.push(cur);
            cur = cur.left;
        }
    }
}
```

### ğŸ˜ [ä¸­åºåç»§](https://leetcode.cn/problems/P5rCT8/)

![image-20231225154313795](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231225154313795.png)

#### æœç´¢æ ‘

```bash
# åä»»
- 1. å…ˆæ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹
- 2. ç›®æ ‡èŠ‚ç‚¹æœ‰å³å­æ ‘ï¼Œ        åä»»å°±æ˜¯å³å­æ ‘çš„æœ€å°å€¼ï¼š                    # 15çš„åä»»æ˜¯18
     ç›®æ ‡èŠ‚ç‚¹æ²¡æœ‰å³å­æ ‘
                  - æœ‰å³è¾¹æ¥çš„ç¥–å…ˆï¼Œ åä»»æ˜¯æœ€è¿‘çš„ä¸€ä¸ªå³è¾¹æ¥çš„parentï¼š       # 6çš„åä»»æ˜¯8ï¼Œ 5çš„åä»»æ˜¯6
                  - æ²¡æœ‰å³è¾¹æ¥çš„ç¥–å…ˆï¼Œ åˆ™åä»»æ˜¯null   
```

```java
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    TreeNode target = root;
    TreeNode rightAncestor = null; // å³è¾¹çš„ç¥–å…ˆ

    /*æ‰¾ç›®æ ‡ç»“ç‚¹*/
    while (target != null) {
        if (target.val < p.val) {
            target = target.right;
        } else if (target.val > p.val) {
            rightAncestor = target;
            target = target.left;
        } else {
            break;
        }
    }

    if (target.right != null) {
        return getMinNode(target.right);
    } else {
        return rightAncestor;
    }
}

/*æ‰¾æœ€å°å€¼*/
private TreeNode getMinNode(TreeNode node) {
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```

#### ä¸­åº - è¿­ä»£

- æ•ˆç‡è¾ƒä½ï¼Œæ²¡æœ‰å……åˆ†åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§
- ä¸­åºéå†ï¼Œæ‰¾åˆ°åé¢ç»“ç‚¹ï¼šåœ¨éå†è¿‡ç¨‹ä¸­ç”¨ç¬¦å·æ ‡è®°ï¼Œä¸€æ—¦æ‰¾åˆ°ç›®æ ‡ç»“ç‚¹äº†ï¼Œåé¢çš„å°±ç«‹åˆ»è¿”å›åé¢çš„ç»“ç‚¹

## éªŒè¯

### ğŸ˜ [98. éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/validate-binary-search-tree/)

#### é€’å½’ + ä¸Šä¸‹è¾¹ç•Œ

![image-20240115142020261](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240115142020261.png)

```java
public boolean isValidBST(TreeNode root) {
    return isValidRecur(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

private boolean isValidRecur(TreeNode root, long low, long high) {
    if (root == null) {
        return true;
    }
    /*å½“å‰ç»“ç‚¹*/
    boolean curResult = root.val > low && root.val < high;
    /*å·¦å­æ ‘*/
    boolean leftResult = isValidRecur(root.left, low, root.val);
    /*å³å­æ ‘*/
    boolean rightResult = isValidRecur(root.right, root.val, high);
    return curResult && leftResult && rightResult;
}
```

#### ä¸­åº-è¿­ä»£

- è·å–ä¸­åºçš„è¿‡ç¨‹ä¸­ï¼Œå°±å»æ¯”è¾ƒä¸€ä¸‹ï¼Œå¦‚æœä¸æ˜¯é€’å¢ï¼Œé‚£ä¹ˆå°±ä¸åˆæ ¼
- ä»£ç ç•¥

#### ä¸­åº-é€’å½’

- é€’å½’è·å–åˆ°æ‰€æœ‰ç»“æœï¼Œä¾æ¬¡æ¯”è¾ƒä¸¤ä¸ªå€¼ï¼Œåˆ¤æ–­æ˜¯å¦åˆæ ¼

```java
private List<Integer> result = new ArrayList<>();

public boolean isValidBST(TreeNode root) {
    inOrder(root);
    for (int i = 0; i < result.size() - 1; i++) {
        if (result.get(i) >= result.get(i + 1)) {
            return false;
        }
    }
    return true;
}

private void inOrder(TreeNode root) {
    if (root == null) {
        return;
    }
    inOrder(root.left);
    result.add(root.val);
    inOrder(root.right);
}
```

## æ“ä½œæ ‘

### âœ… [897. é€’å¢é¡ºåºæœç´¢æ ‘](https://leetcode.cn/problems/increasing-order-search-tree/)

- å°†äºŒå‰æœç´¢æ ‘æŒ‰ç…§ä¸­åºç»“æœï¼Œè½¬æ¢æˆå•é“¾è¡¨

#### ä¸­åº - é€’å½’

```java
private TreeNode sentinel = new TreeNode(-999);
private TreeNode p = sentinel;

public TreeNode increasingBST(TreeNode root) {
    increaseRecur(root);
    return sentinel.right;
}

private void increaseRecur(TreeNode root) {
    if (root == null) {
        return;
    }
    increasingBST(root.left);

    p.right = root;
    p = p.right;

    root.left = null;

    increasingBST(root.right);
}
```

#### ä¸­åº - è¿­ä»£

```java
public TreeNode increasingBST(TreeNode root) {
    TreeNode sentinel = new TreeNode(-999);
    TreeNode p = sentinel;

    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = paths.pop();
            /*è¿æ¥é€»è¾‘*/
            p.right = pop;
            p = p.right;

            pop.left = null;

            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    return sentinel.right;
}
```

### ğŸ˜ [538. äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

#### é€†å‘ä¸­åº

- ä¸€èˆ¬æƒ…å†µä¸­åºæ˜¯å·¦ä¸­å³ï¼Œè¯¥é¢˜ç›®éœ€è¦ç”¨å³ä¸­å·¦

##### é€’å½’

```java
private int sum = 0;

public TreeNode convertBST(TreeNode root) {
    convertRecur(root);
    return root;
}

private void convertRecur(TreeNode root) {
    if (root == null) {
        return;
    }
    convertRecur(root.right);

    int val = root.val;
    root.val += sum;
    sum += val;

    convertRecur(root.left);
}
```

##### è¿­ä»£

```java
public TreeNode convertBST(TreeNode root) {
    if (root == null) {
        return null;
    }

    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;

    int sum = 0;

    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.right;
        } else {
            TreeNode pop = stack.pop();
            // æ”¹å˜å¤§å°
            int val = pop.val;
            pop.val += sum;
            sum += val;

            if (pop.left != null) {
                cur = pop.left;
            }
        }
    }
    return root;
}
```

### ğŸ˜ [1305. ä¸¤æ£µäºŒå‰æœç´¢æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ ](https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/)

- åˆå¹¶æœ‰åºäºŒå‰æ ‘

#### ä¸­åº + æœ‰åºliståˆå¹¶

- å¾—åˆ°ä¸¤ä¸ªæ•°çš„ä¸­åºéå†ç»“æœ
- åˆå¹¶ä¸¤ä¸ªå‡åºé›†åˆ

```java
public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
    List<Integer> list1 = new ArrayList<>();
    List<Integer> list2 = new ArrayList<>();
    inorder(root1, list1);
    inorder(root2, list2);
    return mergeTwoList(list1, list2);
}

/*å¾—åˆ°ä¸¤ä¸ªæœ‰åºlist*/
private void inorder(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }

    inorder(root.left, result);
    result.add(root.val);
    inorder(root.right, result);
}

private List<Integer> mergeTwoList(List<Integer> list1, List<Integer> list2) {
    List<Integer> result = new ArrayList<>();
    int p1 = 0;
    int p2 = 0;

    while (p1 < list1.size() && p2 < list2.size()) {
        Integer data1 = list1.get(p1);
        Integer data2 = list2.get(p2);
        if (data1 < data2) {
            result.add(data1);
            p1++;
        } else {
            result.add(data2);
            p2++;
        }
    }

    if (p1 < list1.size()) {
        // å¤„ç†p1
        while (p1 < list1.size()) {
            result.add(list1.get(p1));
            p1++;
        }
    }

    if (p2 < list2.size()) {
        // å¤„ç†p2
        while (p2 < list2.size()) {
            result.add(list2.get(p2));
            p2++;
        }
    }
    return result;
}
```

### ğŸ˜ [701. æ’å…¥æ“ä½œ](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

- keyå¦‚æœå­˜åœ¨ï¼Œåˆ™æ›´æ–°ï¼Œkeyä¸å­˜åœ¨ï¼Œæ–°å¢å·¦æˆ–å³èŠ‚ç‚¹
- è‚¯å®šä½œä¸ºå¶å­ç»“ç‚¹æ·»åŠ çš„
- ä¸€ä¸ªæ•°ç»„æ·»åŠ åˆ°äºŒå‰æœç´¢æ ‘çš„æ—¶å€™ï¼Œå¦‚æœæ•°ç»„é¡ºåºå˜æ¢ï¼ŒæŒ‰ç…§ç´¢å¼•æ·»åŠ ï¼Œåˆ™æ„å»ºçš„äºŒå‰æœç´¢æ ‘ä¸åŒ

#### é€’å½’

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }

    if (root.val < val) {
        root.right = insertIntoBST(root.right, val);
    } else if (root.val > val) {
        root.left = insertIntoBST(root.left, val);
    } else {
    }
    return root;
}
```

#### è¿­ä»£

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }

    TreeNode cur = root;
    TreeNode targetLeaf = null;
    while (cur != null) {
        if (cur.val < val) {
            targetLeaf = cur;
            cur = cur.right;
        } else if (cur.val > val) {
            targetLeaf = cur;
            cur = cur.left;
        } else {
            // do nothing
        }
    }

    TreeNode inserted = new TreeNode(val);
    if (targetLeaf.val < val) {
        targetLeaf.right = inserted;
    } else {
        targetLeaf.left = inserted;
    }

    return root;
}
```

 ### ğŸ˜ [450. åˆ é™¤èŠ‚ç‚¹](https://leetcode.cn/problems/delete-node-in-a-bst/)

- å¾…åˆ é™¤ç»“ç‚¹å¦‚æœåŒæ—¶å­˜åœ¨å·¦å³å­©å­ï¼šå·¦æŒ‚åœ¨å³ï¼Œå³æŒ‚åœ¨å·¦ï¼Œå‡å¯ã€‚ä¸¤ç§æ–¹å¼æ„å»ºå‡ºçš„äºŒå‰æœç´¢æ ‘ä¸ä¸€æ ·ï¼Œä½†éƒ½åˆæ³•
- å³æŒ‚åœ¨å·¦æˆ–è€…å·¦æŒ‚åœ¨å³å‡å¯

![image-20240116203214793](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240116203214793.png)

```java
private TreeNode rootResult;
private TreeNode removedParent;

public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) {
        return null;
    }

    rootResult = root;

    /*1.æ‰¾åˆ°å¾…åˆ é™¤èŠ‚ç‚¹*/
    TreeNode removed = findRemoved(root, key);
    if (removed == null) {
        return rootResult;
    }

    /*2. åˆ é™¤èŠ‚ç‚¹*/
    if (removed.left == null) {
        // å³èŠ‚ç‚¹æ‰˜å­¤
        shift(removedParent, removed, removed.right);
    } else if (removed.right == null) {
        // å·¦èŠ‚ç‚¹æ‰˜å­¤
        shift(removedParent, removed, removed.left);
    } else {
        // å·¦å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©º
        TreeNode child = rightAttachedLeft(removed.left, removed.right);
        shift(removedParent, removed, child);
    }

    return rootResult;
}

private TreeNode findRemoved(TreeNode root, int key) {
    while (root != null) {
        if (root.val < key) {
            removedParent = root;
            root = root.right;
        } else if (root.val > key) {
            removedParent = root;
            root = root.left;
        } else {
            return root;
        }
    }
    return null;
}

private void shift(TreeNode removedParent, TreeNode removed, TreeNode removedChild) {
    if (removedParent == null) {
        rootResult = removedChild;
    } else {
        if (removedParent.val < removed.val) {
            removedParent.right = removedChild;
        } else {
            removedParent.left = removedChild;
        }
    }
}

/*å·¦æŒ‚åœ¨å³ï¼šæ‰¾å³çš„æœ€å°å€¼*/
private TreeNode leftAttachedRight(TreeNode leftChild, TreeNode rightChild) {
    TreeNode min = rightChild;
    while (min.left != null) {
        min = min.left;
    }
    min.left = leftChild;
    return rightChild;
}

/*å³æŒ‚åœ¨å·¦ï¼šæ‰¾å·¦çš„æœ€å¤§å€¼*/
private TreeNode rightAttachedLeft(TreeNode leftChild, TreeNode rightChild) {
    TreeNode max = leftChild;
    while (max.right != null) {
        max = max.right;
    }
    max.right = rightChild;
    return leftChild;
}
```

# LeetCode

## ğŸ˜[653. ä¸¤æ•°ä¹‹å’Œ IV - è¾“å…¥äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)

- äºŒå‰æœç´¢æ ‘çš„ä¸¤æ•°ä¹‹å’Œ

### ä¸­åº + Hash

- ä¸­åºéå†è½¬æ¢ä¸ºæ’åºæ•°ç»„ï¼Œhashå¯¹æ•°ç»„å¤„ç†

```java
public boolean findTarget(TreeNode root, int k) {
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    ArrayList<Integer> result = new ArrayList<>();

    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = paths.pop();
            result.add(pop.val);
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    Set<Integer> hash = new HashSet<>();
    for (Integer el : result) {
        if (!hash.add(k - el)) {
            return true;
        }
        hash.add(el);
    }
    return false;
}
```

## ğŸ˜¡[230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ ](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

### DFS-ä¸­åº+è¿­ä»£

```java
public int kthSmallest(TreeNode root, int k) {
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    int i = 0;
    int val = 0;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = paths.pop();
            i++;
            if (i == k){
                val = pop.val;
                break;
            }
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }
    return val;
}
```

## ğŸ˜¡[1008. å‰åºéå†æ„é€ äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)

### ä¾æ¬¡put

- å°†æ•°ç»„ä¸­çš„æ•°æ®ä¾æ¬¡æ·»åŠ åˆ°äºŒå‰æœç´¢æ ‘ä¸­
- ä¸èƒ½æœ‰æ•ˆçš„åˆ©ç”¨å‰åºéå†çš„é¡ºåº

```java
public TreeNode bstFromPreorder(int[] preorder) {
    TreeNode root = null;
    for (int i = 0; i < preorder.length; i++) {
        root = put(root, preorder[i]);
    }
    return root;
}


private TreeNode put(TreeNode root, int value) {
    if (root == null) {
        return new TreeNode(value); // ç©ºæ ‘
    }

    TreeNode cur = root;
    TreeNode prev = null;
    while (cur != null) {
        if (cur.val > value) {
            prev = cur;
            cur = cur.left;
        } else if (cur.val < value) {
            prev = cur;
            cur = cur.right;
        } else {
            return root; // åŸæ¥å·²ç»å­˜åœ¨ï¼Œç›´æ¥è¿”å›
        }
    }

    /*å·¦æˆ–å³*/
    TreeNode inserted = new TreeNode(value);
    if (value < prev.val) {
        prev.left = inserted;
    } else {
        prev.right = inserted;
    }
    return root;
}
```



