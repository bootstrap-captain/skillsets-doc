# æ•°æ®ç»“æ„

## 1. æ€æƒ³

![image-20231113094946264](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231113094946264.png)

```bash
# æ•°æ®ç»“æ„
- å»ºç«‹ä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ‰€æœ‰çš„æ•°æ®
- æ¯ä¸ªæ•°æ®å®ä½“ï¼ŒåŒ…å«ä¸€ä¸ªkeyå’Œä¸€ä¸ªvalue
- é€šè¿‡keyæ¥æ˜ å°„åˆ°æ•°ç»„ç´¢å¼•ï¼Œç„¶åå°†æ•°æ®å­˜å‚¨åœ¨è¯¥ç´¢å¼•å¤„

# ç†æƒ³æƒ…å†µ
- æ¯ä¸ªæ•°æ®å®ä½“ï¼Œkeyå”¯ä¸€ï¼Œæ•°ç»„è¶³å¤Ÿå¤§ï¼Œèƒ½å­˜æ”¾æ‰€æœ‰æ•°æ®
- æ¯ä¸ªæ•°ç»„åªå­˜æ”¾ä¸€ä¸ªæ•°æ®

  # ä¼˜ç‚¹
  - æ—¶é—´å¤æ‚åº¦ä¸ºO(1)ï¼Œåªéœ€è¦æ ¹æ®keyæ‰¾åˆ°æ•°ç»„ç´¢å¼•ä½ç½®å³å¯
  # ç¼ºç‚¹
  - æ•°ç»„çš„å†…å­˜è¿ç»­ï¼Œå› æ­¤å¤§æ•°ç»„å¯¹å†…å­˜è¦æ±‚è‹›åˆ»

# æ‹‰é“¾æ³•åˆ™
- æœ‰é™é•¿åº¦çš„æ•°ç»„
- å…è®¸keyé‡å¤ï¼Œå…è®¸å¤šä¸ªkeyæ˜ å°„åŒä¸€ä¸ªç´¢å¼•
- ä¸€ä¸ªç´¢å¼•å¤„çš„æ•°æ®ï¼Œé€šè¿‡é“¾è¡¨æ¥è¿æ¥
- æ—¶é—´å¤æ‚åº¦ä¼šå¢åŠ 
```

```bash
# key(hash)
- æ•°æ®çš„keyï¼Œé€šè¿‡æŸç§è§„åˆ™ï¼Œå¯ä»¥æ˜ å°„åˆ°æ•°ç»„çš„æŸä¸ªç´¢å¼•ä¸Š
- å¦‚æœæ•°ç»„æŸä¸ªç´¢å¼•çš„å­˜å‚¨å…ƒç´ è¿‡å¤šï¼Œåˆ™éœ€è¦éå†é“¾è¡¨ï¼Œæ—¶é—´å¤æ‚åº¦å¢åŠ 

# hashç®—æ³•
- æ·»åŠ æ•°æ®æ—¶ï¼Œç”¨æˆ·æ²¡åŠæ³•ä¿è¯keyçš„åˆ†æ•£æ€§
- å› æ­¤æ ¹æ®å…·ä½“çš„keyå€¼ï¼Œæ¥ç”Ÿæˆä¸€ä¸ªå”¯ä¸€å€¼æ¥ç¡®å®šç´¢å¼•ï¼Œå³hash
```

## 2. å“ˆå¸Œç 

### 2.1 å“ˆå¸Œç®—æ³•

- å°†ä»»æ„é•¿åº¦çš„ä»»æ„æ•°æ®ï¼Œé€šè¿‡ç®—æ³•ï¼Œè½¬æ¢ä¸º<font color=orange>å›ºå®šé•¿åº¦æ•°æ®</font>ï¼Œè¿™ä¸ªå›ºå®šé•¿åº¦çš„æ•°æ®å°±æ˜¯hashå€¼
- MD5ï¼ŒSHA1ï¼ŒSHA256ï¼ŒSHA512ï¼Œ CRC32ç­‰
- è®¡ç®—hashå€¼æ—¶ï¼Œè€ƒè™‘åŸå§‹æ•°æ®çš„æ¯ä¸ªå­—èŠ‚ï¼Œä¸€æ—¦æ”¹åŠ¨åŸå§‹æ•°æ®çš„ä»»ä½•ä¸€ä¸ªå­—èŠ‚ï¼Œå¯¹åº”hashå€¼éƒ½ä¼šæœ‰æ˜æ˜¾ä¸åŒ
- æ‘˜å–äº†åŸå§‹æ•°æ®çš„ä¸€äº›ç‰¹å¾ï¼ŒæŸç§ç¨‹åº¦ä¸Šèƒ½ä»£è¡¨åŸå§‹æ•°æ®
- è¢«å¹¿æ³›ç”¨äºæ•°æ®å®Œæ•´æ€§æ ¡éªŒå’ŒåŠ å¯†æ–¹é¢

### 2.2 å®ç°æ–¹å¼

#### Object-hashCode

```java
/*åŒä¸€ä¸ªå¯¹è±¡çš„hashå€¼ç›¸åŒ*/
public void test01() {
    Object obj = new Object();
    for (int i = 0; i < 100; i++) {
        int result = obj.hashCode();
        System.out.println(result); // 757108857
    }
}

/*ä¸åŒå¯¹è±¡çš„hashå€¼ä¸åŒ*/
public void test02() {
    for (int i = 0; i < 100; i++) {
        Object obj = new Object();
        int result = obj.hashCode();
        System.out.println(result);
    }
}
```

#### æƒé‡Hash

- ä¸€ä¸ªå¯¹è±¡é‡Œé¢ï¼Œå¯¹äºä¸åŒçš„å­—æ®µï¼Œç»™äºˆä¸åŒçš„æƒé‡
- ç»éªŒè¡¨æ˜ï¼Œæƒé‡é€‰å–è´¨æ•°31ï¼Œå“ˆå¸Œå†²çªçš„æ¦‚ç‡æ¯”è¾ƒä½

```java
 /**
 * ä¸åŒçš„å­—æ®µï¼Œå…¶hashçš„æƒé‡ä¸åŒ
 * field1*31 + field2*31*31 + field3*31*31*31 +...
 *
 * @param objs
 * @return
 */
public static int getHash(Object... objs) {
    if (objs == null) {
        return 0;
    }

    int result = 1;
    for (Object obj : objs) {
        if (obj == null) {
            result = result * 31;
        } else {
            result = result * 31 + obj.hashCode();
        }
    }
    return result;
}
```

```java
 /**
   * ä¼˜åŒ–ï¼šä¹˜æ³•å˜æˆä½è¿ç®—
   *
   * @param objs
   * @return
   */
  public static int getHash(Object... objs) {
      if (objs == null) {
          return 0;
      }

      int result = 1;
      for (Object obj : objs) {
          if (obj == null) {
              result = result << 5 - result;
          } else {
              result = result << 5 - result + obj.hashCode();
          }
      }
      return result;
  }
```

#### MurmurHash

- å¿«é€Ÿè®¡ç®—ï¼šç›¸å¯¹äºå…¶ä»–å“ˆå¸Œå‡½æ•°ï¼Œå…·æœ‰æ›´å¿«çš„è®¡ç®—é€Ÿåº¦
- ä½ç¢°æ’ç‡ï¼šå¤„ç†ä¸€äº¿ä¸ªæ•°æ®ï¼Œæœ€å¤šåªæœ‰ä¸¤ä¸ªå†²çª
- éšæœºæ€§å¼ºï¼šèƒ½å¤Ÿå¾ˆå¥½çš„ä¿æŒæ•°æ®çš„éšæœºæ€§

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>32.1.2-jre</version>
</dependency>
```

```java
// å¯¹ä¸åŒç±»å‹æ•°æ®è¿›è¡Œhash
int i = Hashing.murmur3_32_fixed().hashInt(3).asInt();
```

## 3. åŸºæœ¬æ–¹æ³•

### 3.1 hash-indexæ˜ å°„

- æ ¹æ®å¯¹åº”çš„hash(intç±»å‹çš„å¤§çš„æ•°å­—ï¼Œæ ¹æ®æ•°ç»„é•¿åº¦æ¥æ±‚æ¨¡)
- æ•°ç»„é•¿åº¦ä¸º2çš„æ¬¡æ–¹æ—¶ï¼Œæ±‚æ¨¡å¯ä»¥è½¬æ¢ä¸ºä½è¿ç®—ï¼Œæ•ˆç‡æ›´é«˜

![image-20231113160711854](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231113160711854.png)

```java
/*æ ¹æ®keyè·å–åˆ°hashï¼Œå†é€šè¿‡hashæ¥æ±‚index*/
private int getIndex(Object key) {
    int hash = key.hashCode();
    return hash & (table.length - 1);
}
```

### 3.2 resize

- å¦‚æœä¸æ·»åŠ resizeï¼Œåˆ™æœ€ç»ˆéšç€æ•°æ®è¶Šæ¥è¶Šå¤šï¼Œæ•°ç»„ä¸Šçš„é“¾è¡¨ä¹Ÿä¼šè¶Šæ¥è¶Šé•¿
- æ·»åŠ æ•°æ®å®Œæˆåï¼Œè¿›è¡Œresizeé€‚å½“æ‰©å®¹ï¼Œå°½å¯èƒ½ä¿è¯æ•°ç»„æ¯ä¸ªéƒ½åªå­˜æ”¾ä¸€ä¸ªå…ƒç´ 

```bash
# hashå†²çª (å³ä½¿å­˜åœ¨æ‰©å®¹)
- ä¸åŒçš„keyï¼Œæœ€ç»ˆå¾—åˆ°çš„hashä¸€æ ·ï¼Œå°±ä¼šå¾—åˆ°ç›¸åŒçš„index
- ä¸åŒçš„keyï¼Œhashè™½ç„¶ä¸åŒï¼Œä½†æ˜¯æ±‚å¾—åˆ°çš„indexæ˜¯ä¸€æ ·çš„

# æœ€ç»ˆç»“æœ
- æ•°ç»„çš„æŸäº›ä½ç½®ä¸Šï¼Œå…ƒç´ çš„ä¸ªæ•°è¶…è¿‡1
```

#### æ‹†åˆ†è§„å¾‹

- ä¸€ä¸ªé“¾è¡¨æœ€å¤šæ‹†æˆä¸¤ä¸ª
- hash & table.length==0çš„ä¸€ç»„
- hash & table.length!=0çš„ä¸€ç»„

### 4.4 put

```java
// keyé‡å¤ï¼Œåˆ™æ›´æ–°ï¼Œkeyä¸å­˜åœ¨ï¼Œåˆ™å°¾éƒ¨æ·»åŠ 
public void put(Object key, Object value) {
    int hash = getHash(key);
    int targetIndex = getIndex(hash);

    if (table[targetIndex] == null) {
        table[targetIndex] = new Entry(key, value);
    } else {// éå†å¯»æ‰¾
        Entry entry = table[targetIndex];
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value; // æ›´æ–°
                return;
            }
            if (entry.next == null) {
                break;
            }
            entry = entry.next;
        }
        entry.next = new Entry(key, value);
    }

    size++;
    if (size > threshold) {
        resize();
    }
}
```

# è®¾è®¡

## âœ… [706. HashMap](https://leetcode.cn/problems/design-hashmap/)

- æ‰©å®¹æœºåˆ¶å¾…å®š

```java
class MyHashMap {

    static class Entry {
        Object key;
        Object value;

        Entry next;

        public Entry(Object key, Object value) {
            this.key = key;
            this.value = value;
        }

        public Entry(Object key, Object value, Entry next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    private Entry[] table = new Entry[16];

    public MyHashMap() {
    }


    /*å¤´æ’*/
    public void put(int key, int value) {
        int index = getIndex(key);
        Entry cur = table[index];

        /*æ›´æ–°çš„è¯å¯ä»¥ç›´æ¥ç»“æŸæ–¹æ³•*/
        while (cur != null) {
            if (cur.key.equals(key)) {
                cur.value = value;
                return;
            }
            cur = cur.next;
        }

        /*å¤´æ’*/
        table[index] = new Entry(key, value, table[index]);
    }

    public int get(int key) {
        int index = getIndex(key);
        Entry entry = table[index];

        while (entry != null) {
            if (entry.key.equals(key)) {
                return (int) entry.value;
            }
            entry = entry.next;
        }

        return -1;
    }

    public void remove(int key) {
        int index = getIndex(key);
        Entry entry = table[index];
        Entry newHead = removeByKey(entry, key);
        table[index] = newHead;
    }

    private Entry removeByKey(Entry head, int key) {
        Entry sentinel = new Entry(-999, -999, head);
        Entry prev = sentinel;
        Entry cur = sentinel.next;
        while (cur != null) {
            if (cur.key.equals(key)) {
                prev.next = cur.next;
                break;
            }
            prev = prev.next;
            cur = cur.next;
        }
        return sentinel.next;
    }

    /*æ ¹æ®keyè·å–åˆ°hashï¼Œå†é€šè¿‡hashæ¥æ±‚index*/
    private int getIndex(Object key) {
        int hash = key.hashCode();
        return hash & (table.length - 1);
    }
}
```

## âœ… [705. HashSet](https://leetcode.cn/problems/design-hashset/)

- ç±»ä¼¼HashMapï¼Œä¸è¿‡å¯¹åº”çš„Valueç”¨nullè¡¨ç¤º

```java
class MyHashSet {

    static class Entry {
        Object key;
        Object value;
        Entry next;

        public Entry(Object key, Object value) {
            this.key = key;
            this.value = value;
        }

        public Entry(Object key, Object value, Entry next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    private Entry[] table = new Entry[16];

    public MyHashSet() {
    }

    public void add(int key) {
        int index = getIndex(key);
        Entry head = table[index];

        /*å¦‚æœkeyç›¸åŒï¼Œåˆ™ä»€ä¹ˆä¹Ÿä¸ç”¨åš*/
        while (head != null) {
            if (head.key.equals(key)) {
                return;
            }
            head = head.next;
        }

        /*å¤´æ’*/
        Entry inserted = new Entry(key, null, table[index]);
        table[index] = inserted;
    }

    public void remove(int key) {
        int index = getIndex(key);
        Entry head = table[index];
        table[index] = removeByKey(head, key);
    }

    private Entry removeByKey(Entry head, int key) {
        Entry sentinel = new Entry(-999, -999, head);
        Entry prev = sentinel;
        Entry cur = sentinel.next;
        while (cur != null) {
            if (cur.key.equals(key)) {
                prev.next = cur.next;
                break;
            }

            prev = prev.next;
            cur = cur.next;
        }
        return sentinel.next;
    }

    public boolean contains(int key) {
        int index = getIndex(key);
        Entry head = table[index];
        while (head != null) {
            if (head.key.equals(key)) {
                return true;
            }
            head = head.next;
        }

        return false;
    }

    private int getIndex(Object key) {
        return key.hashCode() & (table.length - 1);
    }
}
```

## ğŸ˜ [146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)

- é€å‡ºæœ€è¿‘æœ€å°‘ä½¿ç”¨
- Least Recently Usedï¼šæœ€è¿‘æœ€å°‘ä½¿ç”¨

```bash
# æ€è·¯ï¼š åŒå‘é“¾è¡¨ï¼Œå¤´æŒ‡é’ˆæ–¹ä¾¿putï¼Œå°¾æŒ‡é’ˆæ–¹ä¾¿é€å‡º
- é“¾è¡¨å¤´ï¼š  æœ€è¿‘ä½¿ç”¨çš„
- é“¾è¡¨å°¾ï¼š  é€æ¸æ²¡è¢«ä½¿ç”¨çš„
- æ¯æ¬¡getå’Œputï¼Œéƒ½å°†è¯¥å…ƒç´ ç§»åŠ¨åˆ°é“¾è¡¨å¤´

# Hash
- ä¿è¯getæ—¶å€™æ—¶é—´å¤æ‚åº¦ä¸ºO1
- keyï¼š  å¯¹åº”Nodeçš„key
- valueï¼šå¯¹åº”Nodeåœ¨é“¾è¡¨ä¸­çš„åœ°å€ï¼Œä¸æ˜¯å•ç‹¬çš„ç»“ç‚¹
```

![image-20240103210023864](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240103210023864.png)

```java
class LRUCache {

    static class Node {
        int key;
        int value;
        Node prev;
        Node next;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private HashMap<Integer, Node> hash = new HashMap();

    private Node dummyHead = new Node(-999, -999);
    private Node dummyTail = new Node(-888, -888);

    private int size;
    private int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        dummyHead.next = dummyTail;
        dummyTail.prev = dummyHead;
    }

    public int get(int key) {
        Node node = hash.get(key);
        if (node == null) {
            return -1;
        } else {
            // ç§»åŠ¨å…ƒç´ ï¼šåœ¨é“¾è¡¨å’Œhashä¸­
            delete(node);
            addFirst(node);
            return node.value;
        }
    }

    public void put(int key, int value) {
        if (hash.containsKey(key)) { // æ›´æ–°
            Node node = hash.get(key);
            node.value = value;
            delete(node);
            addFirst(node);
        } else {
            if (size == capacity) {
                delete(dummyTail.prev);
            }
            addFirst(new Node(key, value));
        }
    }

    /*é“¾è¡¨çš„deleteä»¥åŠhashçš„delete*/
    private void delete(Node node) {
        Node prev = node.prev;
        Node next = node.next;
        prev.next = next;
        next.prev = prev;
        hash.remove(node.key);
        size--;
    }

    /*é“¾è¡¨çš„addä»¥åŠhashçš„add*/
    private void addFirst(Node node) {
        Node head = dummyHead.next; // å¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ª
        dummyHead.next = node;
        node.prev = dummyHead;
        node.next = head;
        head.prev = node;

        hash.put(node.key, node);
        size++;
    }
}
```

## ğŸ›³ [460. LFU ç¼“å­˜](https://leetcode.cn/problems/lfu-cache/)

- åŒå“ˆå¸Œ + åŒå‘é“¾è¡¨
- 

# LeetCode

## âœ… [383. èµé‡‘ä¿¡](https://leetcode.cn/problems/ransom-note/)

### 26æ•°ç»„

```java
public boolean canConstruct(String ransomNote, String magazine) {
    if (ransomNote.length() > magazine.length()) {
        return false;
    }

    int[] chs1 = calculate(ransomNote);
    int[] chs2 = calculate(magazine);
    for (int i = 0; i < chs1.length; i++) {
        if (chs1[i] > chs2[i]) {
            return false;
        }
    }
    return true;
}

private int[] calculate(String s) {
    int[] arr = new int[26];
    char[] chs = s.toCharArray();
    for (char ch : chs) {
        arr[ch - 'a']++;
    }
    return arr;
}
```

### Hash

```java
public boolean canConstruct(String ransomNote, String magazine) {
    Map<Character, Integer> first = getHash(ransomNote);
    Map<Character, Integer> second = getHash(magazine);

    for (Map.Entry<Character, Integer> entry : first.entrySet()) {
        Character key = entry.getKey();
        Integer value = entry.getValue();

        if (!second.containsKey(key) || second.get(key) < value) {
            return false;
        }
    }
    return true;
}

private Map<Character, Integer> getHash(String s) {
    Map<Character, Integer> hash = new HashMap<>();
    char[] chs = s.toCharArray();
    for (char ch : chs) {
        if (!hash.containsKey(ch)) {
            hash.put(ch, 1);
        } else {
            hash.put(ch, hash.get(ch) + 1);
        }
    }

    return hash;
}
```

## âœ… [205. åŒæ„å­—ç¬¦ä¸²](https://leetcode.cn/problems/isomorphic-strings/)

### åŒHash

```java
public boolean isIsomorphic(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }

    char[] chs1 = s.toCharArray();
    char[] chs2 = t.toCharArray();

    Map<Character, Character> firstHash = new HashMap<>();
    Map<Character, Character> secondHash = new HashMap<>();
    for (int i = 0; i < chs1.length; i++) {
        char ch1 = chs1[i];
        char ch2 = chs2[i];

        // ç¬¬ä¸€ä¸ªhash
        if (!firstHash.containsKey(ch1)) {
            firstHash.put(ch1, ch2);
        } else {
            if (firstHash.get(ch1) != ch2) {
                return false;
            }
        }

        // ç¬¬äºŒä¸ªhash
        if (!secondHash.containsKey(ch2)) {
            secondHash.put(ch2, ch1);
        } else {
            if (secondHash.get(ch2) != ch1) {
                return false;
            }
        }
    }

    return true;
}
```

## âœ… [290. å•è¯è§„å¾‹](https://leetcode.cn/problems/word-pattern/)

### åŒHash

```java
public boolean wordPattern(String pattern, String s) {
    String[] s1 = s.split(" ");
    if (pattern.length() != s1.length) {
        return false;
    }

    Map<Character, String> firstHash = new HashMap<>();
    Map<String, Character> secondHash = new HashMap<>();
    char[] chs = pattern.toCharArray();
    for (int i = 0; i < chs.length; i++) {
        char ch = chs[i];
        if (!firstHash.containsKey(ch)) {
            firstHash.put(ch, s1[i]);
        } else {
            if (!firstHash.get(ch).equals(s1[i])) {
                return false;
            }
        }

        if (!secondHash.containsKey(s1[i])) {
            secondHash.put(s1[i], ch);
        } else {
            if (secondHash.get(s1[i]) != ch) {
                return false;
            }
        }
    }

    return true;
}
```

## âœ… [242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯](https://leetcode.cn/problems/valid-anagram/)

### 26æ•°ç»„

```java
public boolean isAnagram(String s, String t) {
    int[] first = getArr(s);
    int[] second = getArr(t);
    for (int i = 0; i < first.length; i++) {
        if (first[i] != second[i]) {
            return false;
        }
    }
    return true;
}

private int[] getArr(String s) {
    char[] chs = s.toCharArray();
    int[] arr = new int[26];
    for (int i = 0; i < chs.length; i++) {
        int index = chs[i] - 'a';
        arr[index]++;
    }
    return arr;
}
```

## ğŸ˜ [49. å­—æ¯å¼‚ä½è¯åˆ†ç»„](https://leetcode.cn/problems/group-anagrams/)

### Hash + 26æ•°ç»„

- éœ€è¦é‡å†™26æ•°ç»„çš„å°è£…ç±»çš„hashcodeå’Œequalsæ–¹æ³•

```java
static class PArray {
        int[] arr = new int[26];

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            PArray pArray = (PArray) o;
            return Arrays.equals(arr, pArray.arr);
        }

        @Override
        public int hashCode() {
            return Arrays.hashCode(arr);
        }
    }

    public List<List<String>> groupAnagrams(String[] strs) {
        Map<PArray, List<String>> hash = new HashMap<>();
        for (int i = 0; i < strs.length; i++) {
            String str = strs[i];
            PArray parray = getArr(str);
            if (!hash.containsKey(parray)) {
                ArrayList<String> subResult = new ArrayList<>();
                subResult.add(str);
                hash.put(parray, subResult);
            } else {
                hash.get(parray).add(str);
            }
        }
        
        List<List<String>> result = new ArrayList<>();
        for (Map.Entry<PArray, List<String>> entry : hash.entrySet()) {
            result.add(entry.getValue());
        }
        
        return result;
    }

    private PArray getArr(String str) {
        PArray pArray = new PArray();
        char[] chs = str.toCharArray();
        for (int i = 0; i < chs.length; i++) {
            char ch = chs[i];
            int index = ch - 'a';
            pArray.arr[index]++;
        }
        return pArray;
    }
```

## âœ… [1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum/)

### Hash

- keyï¼šæ•°å­—å€¼ã€‚ valueï¼šç´¢å¼•

```java
public int[] twoSum(int[] nums, int target) {
    int[] arr = new int[2];
    Map<Integer, Integer> hash = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        if (hash.containsKey(target - num)) {
            arr[0] = hash.get(target - num);
            arr[1] = i;
        } else {
            hash.put(num, i);
        }
    }
    return arr;
}
```

## ğŸ˜[3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

### Hash

- abbaæƒ…å†µ

![image-20240103232253672](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240103232253672.png)

```java
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> hash = new HashMap<>();
    int start = 0;
    int end = 0;
    char[] chs = s.toCharArray();
    int max = 0;

    for (int i = 0; i < chs.length; i++) {
        char ch = chs[i];
        if (hash.containsKey(ch)) {
            Integer index = hash.get(ch);// å¾—åˆ°é‡å¤å…ƒç´ çš„ç´¢å¼•
            if (index >= start) {// é‡å¤å…ƒç´ çš„ç´¢å¼•å¿…é¡»å¤§äºç­‰äºstart
                start = index + 1;
            }
        }
        hash.put(ch, i); // æ›´æ–°ç´¢å¼•
        end++;
        max = Math.max(end - start, max);
    }
    return max;
}
```

## âœ…[217. å­˜åœ¨é‡å¤å…ƒç´ ](https://leetcode.cn/problems/contains-duplicate/)

### Hash

```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> hash = new HashSet<>();
    for (int i = 0; i < nums.length; i++) {
        if (hash.contains(nums[i])) {
            return true;
        }
        hash.add(nums[i]);
    }
    return false;
}
```

## âœ…[219. å­˜åœ¨é‡å¤å…ƒç´  II](https://leetcode.cn/problems/contains-duplicate-ii/)

### Hash

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> hash = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        if (hash.get(num) != null && Math.abs(hash.get(num) - i) <= k) {
            return true;
        } else {
            hash.put(num, i);
        }
    }
    return false;
}
```

## âœ…[349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](https://leetcode.cn/problems/intersection-of-two-arrays/)

### Hash

```java
  public int[] intersection(int[] nums1, int[] nums2) {
      Set<Integer> result = new HashSet<>();

      Set<Integer> hash = new HashSet<>();
      for (int i = 0; i < nums1.length; i++) {
          hash.add(nums1[i]);
      }
      for (int i = 0; i < nums2.length; i++) {
          if (hash.contains(nums2[i])) {
              result.add(nums2[i]);
          }
      }

      int[] arr = new int[result.size()];
      int i = 0;
      for (Integer el : result) {
          arr[i] = el;
          i++;
      }
      return arr;
  }
```

## âœ… [387. å­—ç¬¦ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªå”¯ä¸€å­—ç¬¦](https://leetcode.cn/problems/first-unique-character-in-a-string/)

- å¿…é¡»ç¬¬ä¸€æ¬¡å…ˆå…¨éƒ¨éå†å­—ç¬¦ä¸²

### Hash

```java
public int firstUniqChar(String s) {
    Map<Character, Integer> hash = new HashMap<>();
    char[] chs = s.toCharArray();

    /*chä½œä¸ºkeyï¼Œé¢‘æ¬¡ä½œä¸ºvalue*/
    for (int i = 0; i < chs.length; i++) {
        char ch = chs[i];
        if (!hash.containsKey(ch)) {
            hash.put(ch, 1);
        } else {
            hash.put(ch, hash.get(ch) + 1);
        }
    }

    /*å†æ¬¡éå†æ•°ç»„*/
    for (int i = 0; i < chs.length; i++) {
        char ch = chs[i];
        if (hash.get(ch).equals(1)) {
            return i;
        }
    }
    return -1;
}
```

### 26 æ•°ç»„

- ä¸€èˆ¬é¢˜ç›®è¯´å­—ç¬¦ä¸²åªåŒ…å«å°å†™å­—æ¯ï¼Œå°±å¯ä»¥è€ƒè™‘26æ•°ç»„

```java
public int firstUniqChar(String s) {
    int[] arr = new int[26];
    char[] chs = s.toCharArray();

    for (int i = 0; i < chs.length; i++) {
        char ch = chs[i]; // ç¡®å®šç´¢å¼•
        arr[ch - 'a']++;
    }

    for (int i = 0; i < chs.length; i++) {
        char ch = chs[i];
        if (arr[ch - 'a'] == 1) {
            return i;
        }
    }

    return -1;
}
```

## âœ… [268. ä¸¢å¤±çš„æ•°å­—](https://leetcode.cn/problems/missing-number/)

### Hash

```java
public int missingNumber(int[] nums) {
    Set<Integer> hash = new HashSet<>();
    for (int i = 0; i < nums.length; i++) {
        hash.add(nums[i]);
    }

    for (int i = 0; i <= nums.length; i++) {
        if (hash.add(i)) {
            return i;
        }
    }

    return -1;
}
```

### æ€»æ•°å’Œ

```bash
# å‡å¦‚æ•°ç»„é•¿åº¦=3ï¼Œåˆ™æ€»æ•°å’Œä¸º 0+1+2+3
```

```java
public int missingNumber(int[] nums) {
    int sum = (int) ((nums.length + 1) * nums.length/ 2d);
    for (int i = 0; i < nums.length; i++) {
        sum -= nums[i];
    }
    return sum;
}
```

