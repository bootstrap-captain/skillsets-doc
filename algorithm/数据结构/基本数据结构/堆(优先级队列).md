# æ•°æ®ç»“æ„

- å †æ˜¯ä¸€ç§ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œå¯ä»¥é€šè¿‡æ•°ç»„çš„æ–¹å¼å®ç°

## 1. å¤§é¡¶å †/å°é¡¶å †

- å°é¡¶å †å’Œå¤§é¡¶å †åŸºæœ¬é€»è¾‘ç±»ä¼¼
- ä»¥å¤§é¡¶å †ä¸ºä¾‹

```bash
# å¤§é¡¶å †ï¼š ä»»æ„èŠ‚ç‚¹éƒ½å°äºå…¶çˆ¶èŠ‚ç‚¹
# å°é¡¶å †ï¼š ä»»æ„èŠ‚ç‚¹éƒ½å¤§äºå…¶çˆ¶èŠ‚ç‚¹
- å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹å…³ç³»ä¸å®š

# ç´¢å¼•åŸåˆ™ï¼šç´¢å¼•0å¼€å§‹å­˜å‚¨ï¼Œiè¡¨ç¤ºç´¢å¼•
- èŠ‚ç‚¹içš„çˆ¶èŠ‚ç‚¹ï¼š       floor((i-1)/2)      å½“iå¤§äº0æ—¶
- èŠ‚ç‚¹içš„å·¦å­èŠ‚ç‚¹ä¸ºï¼š    2i+1                ç»“æœä¸èƒ½å¤§äºsize
- èŠ‚ç‚¹içš„å³å­èŠ‚ç‚¹ä¸ºï¼š    2i+2                ç»“æœä¸èƒ½å¤§äºsize
```

![image-20231023190718489](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023190718489.png)

### offer

```bash
# offerï¼š æ–°å…ƒç´ ï¼ŒåŠ å…¥åˆ°æ•°ç»„æœ«å°¾(sizeå±æ€§)

# upï¼šä¸æ–­æ¯”è¾ƒæ–°åŠ å…ƒç´ ä¸å…¶çˆ¶èŠ‚ç‚¹çš„å€¼
- çˆ¶èŠ‚ç‚¹æ›´å°ï¼Œåˆ™äº¤æ¢çˆ¶å­èŠ‚ç‚¹ï¼Œç»§ç»­å‘ä¸Šæ‰¾parent
- ç›´åˆ°çˆ¶èŠ‚ç‚¹å€¼æ›´å¤§
```

![image-20231208105006994](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231208105006994.png)

### poll

```bash
# pollï¼š åˆ é™¤å †é¡¶å¤„çš„å…ƒç´ 
- 1. å †é¡¶å…ƒç´  å’Œæœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢ (æœ€åä¸€ä¸ªå…ƒç´ ä¸ä¸€å®šæ˜¯å †ä¸­æœ€å°çš„)
- 2. åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ 
- 3. å¯¹å †é¡¶å…ƒç´ è¿›è¡Œä¸‹æ½œ

# å †é¡¶å…ƒç´ ä¸‹æ½œï¼š æ¯”å·¦å³å­©å­æœ€å¤§çš„å°
- å½“å‰èŠ‚ç‚¹çš„å€¼æ¯”å·¦å³å­©å­æœ€å¤§çš„ äº¤æ¢
```

### heapify

- å¯¹ä¸€ä¸ªéšæœºæ•°ç»„è¿›è¡Œå †åŒ–

```bash
# å¯¹ç°æœ‰æ•°ç»„è¿›è¡Œé‡æ’
- æ‰¾åˆ°æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹
- ä»åå‘å‰ï¼Œå¯¹æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œä¸‹æ½œï¼ˆæ¯”è¾ƒå·¦å³å€¼ï¼‰

# éå¶å­èŠ‚ç‚¹
- æ²¡æœ‰ä»»ä½•ä¸€ä¸ªå·¦å­©å­æˆ–è€…å³å­©å­
- æœ€åä¸€ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹
```

![image-20231023152506251](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023152506251.png)

```java
package com.citi.stack;

public class MaxHeap {
    int[] arr;
    int size;

    public MaxHeap(int[] arr) {
        this.arr = arr;
        this.size = arr.length;
        heapfiy();
    }

    private void heapfiy() {
        // æœ€åä¸€ä¸ªéå¶å­ç»“ç‚¹
        int nonLeafIndex = (size / 2) - 1;
        for (int i = nonLeafIndex; i >= 0; i--) {
            downRecur(i);
        }
    }

    /*down-é€’å½’å®ç°*/
    private void downRecur(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        int maxIndex = parentIndex;
        // å¤§é¡¶å †å’Œå°é¡¶å †çš„å®ç°ï¼šåªéœ€è¦æ”¹å˜ç¬¦å·å³å¯
        if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
            maxIndex = leftChildIndex;
        }

        if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
            maxIndex = rightChildIndex;
        }

        // é€’å½’ç»“æŸæ¡ä»¶
        if (parentIndex != maxIndex) {
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            downRecur(parentIndex);
        }
    }

    /*down-è¿­ä»£å®ç°*/
    private void downIterator(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        while (true) {
            int maxIndex = parentIndex;
            if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
                maxIndex = leftChildIndex;
            }

            if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
                maxIndex = rightChildIndex;
            }

            if (maxIndex == parentIndex) { // ç»ˆæ­¢
                break;
            }
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            leftChildIndex = parentIndex * 2 + 1;
            rightChildIndex = parentIndex * 2 + 2;
        }
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 2. è‡ªå®šä¹‰å †

- ä¸‹æ½œæ“ä½œï¼Œå¯ä»¥é€šè¿‡è¿­ä»£å’Œé€’å½’ä¸¤ç§å®ç°

### 2.1 æŠ½è±¡ç±»

```java
abstract class AbstractHeap {
    /*æ•°ç»„æ‰©å®¹éƒ¨åˆ†ä¸å®ç°ï¼Œç»™ä¸ªé»˜è®¤å€¼*/
    private static final int DEFAULT_CAPACITY = 50000;
    public int[] arr = new int[DEFAULT_CAPACITY];
    public int size;

    /*æ’å…¥æ“ä½œ*/
    public boolean offer(int val) {
        arr[size] = val;
        up(size);
        size++;
        return true;
    }

    public abstract void up(int index);

    /*å¼¹å‡ºæ“ä½œ*/
    public int poll() {
        if (isEmpty()) {
            return -999;
        }
        int result = arr[0];
        swap(size - 1, 0);
        size--;
        down(0);
        return result;
    }

    public abstract void down(int parentIndex);

    public int peek() {
        if (isEmpty()) {
            return -999;
        }
        return arr[0];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public void swap(int aIndex, int bIndex) {
        int temp = arr[aIndex];
        arr[aIndex] = arr[bIndex];
        arr[bIndex] = temp;
    }
}
```

### 2.2 MaxHeap

#### è¿­ä»£

```java
class MaxHeap extends AbstractHeap {

    @Override
    public void up(int childIndex) {
        int parentIndex = (childIndex - 1) / 2;
        // parentIndexæœ€ç»ˆå’ŒchildIndexéƒ½ä¸º0
        while (arr[parentIndex] < arr[childIndex]) {
            swap(childIndex, parentIndex);
            childIndex = parentIndex;
            parentIndex = (childIndex - 1) / 2;
        }
    }

    @Override
    public void down(int parentIndex) {
        int leftIndex = parentIndex * 2 + 1;
        int rightIndex = parentIndex * 2 + 2;

        // å·¦å’Œå³å­©å­éƒ½å¯èƒ½å·²ç»è¶Šç•Œ
        while (true) {
            int maxIndex = parentIndex;
            if (leftIndex < size && arr[leftIndex] > arr[maxIndex]) {
                maxIndex = leftIndex;
            }

            if (rightIndex < size && arr[rightIndex] > arr[maxIndex]) {
                maxIndex = rightIndex;
            }
            if (maxIndex == parentIndex) {
                break;
            }
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            leftIndex = parentIndex * 2 + 1;
            rightIndex = parentIndex * 2 + 2;
        }
    }
}
```

#### é€’å½’

```java
class MaxHeap extends AbstractHeap {

    @Override
    public void up(int childIndex) {
        int parentIndex = (childIndex - 1) / 2;
        if (arr[parentIndex] < arr[childIndex]) {
            swap(childIndex, parentIndex);
            childIndex = parentIndex;
            up(childIndex);
        }
    }

    @Override
    public void down(int parentIndex) {
        int leftIndex = parentIndex * 2 + 1;
        int rightIndex = parentIndex * 2 + 2;

        int maxIndex = parentIndex;
        if (leftIndex < size && arr[leftIndex] > arr[maxIndex]) {
            maxIndex = leftIndex;
        }

        if (rightIndex < size && arr[rightIndex] > arr[maxIndex]) {
            maxIndex = rightIndex;
        }

        if (maxIndex != parentIndex) {
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            down(parentIndex);
        }
    }
}
```

### 2.3 MinHeap

#### è¿­ä»£

```java
class MinHeap extends AbstractHeap {

    @Override
    public void up(int childIndex) {
        int parentIndex = (childIndex - 1) / 2;

        while (arr[parentIndex] > arr[childIndex]) {
            swap(childIndex, parentIndex);
            childIndex = parentIndex;
            parentIndex = (childIndex - 1) / 2;
        }
    }

    @Override
    public void down(int parentIndex) {
        int leftIndex = parentIndex * 2 + 1;
        int rightIndex = parentIndex * 2 + 2;

        while (true) {
            int maxIndex = parentIndex;
            if (leftIndex < size && arr[leftIndex] < arr[maxIndex]) {
                maxIndex = leftIndex;
            }

            if (rightIndex < size && arr[rightIndex] < arr[maxIndex]) {
                maxIndex = rightIndex;
            }
            if (maxIndex == parentIndex) {
                break;
            }
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            leftIndex = parentIndex * 2 + 1;
            rightIndex = parentIndex * 2 + 2;
        }
    }
}
```

#### é€’å½’

```java
class MinHeap extends AbstractHeap {

    @Override
    public void up(int childIndex) {
        int parentIndex = (childIndex - 1) / 2;
        if (arr[parentIndex] > arr[childIndex]) {
            swap(childIndex, parentIndex);
            childIndex = parentIndex;
            up(childIndex);
        }
    }

    @Override
    public void down(int parentIndex) {
        int leftIndex = parentIndex * 2 + 1;
        int rightIndex = parentIndex * 2 + 2;

        int maxIndex = parentIndex;
        if (leftIndex < size && arr[leftIndex] < arr[maxIndex]) {
            maxIndex = leftIndex;
        }

        if (rightIndex < size && arr[rightIndex] < arr[maxIndex]) {
            maxIndex = rightIndex;
        }

        if (maxIndex != parentIndex) {
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            down(parentIndex);
        }
    }
}
```

## 3. JDK-PriorityQueue

- é»˜è®¤æ¯”è¾ƒå™¨ï¼šå°é¡¶å †

```java
PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));      // å¤§é¡¶å †
PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));      // å°é¡¶å †ï¼Œé»˜è®¤

PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((a, b) -> a.val - b.val); // å¤§é¡¶å †
PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((a, b) -> a.val - b.val); // å°é¡¶å †
```

```java
/*å»ºç«‹æ¯”è¾ƒè§„åˆ™*/
PriorityQueue<Map.Entry<String, Integer>> minHeap =
        new PriorityQueue<>(new Comparator<Map.Entry<String, Integer>>() {
            @Override
            public int compare(Map.Entry<String, Integer> a, Map.Entry<String, Integer> b) {
                if (!a.getValue().equals(b.getValue())) {
                    return a.getValue() - b.getValue();
                } else {
                    // æŒ‰ç…§å­—å…¸è¡¨
                    return a.getKey().charAt(0) - b.getKey().charAt(0);
                }
            }
        });
```

# ğŸ›³  [295. æ•°æ®æµçš„ä¸­ä½æ•°](https://leetcode.cn/problems/find-median-from-data-stream/)

## å¤§é¡¶å † + å°é¡¶å †

```bash
# æ€è·¯ï¼šæ„å»ºä¸€ä¸ªå¤§é¡¶å †ï¼Œä¸€ä¸ªå°é¡¶å †ï¼Œå¤§é¡¶å †çš„å †é¡¶å…ƒç´ å°äºå°é¡¶å †çš„å †é¡¶å…ƒç´ 
      -- å¤§é¡¶å †æ•°æ®ï¼šä¸­ä½æ•°çš„å‰åŠéƒ¨åˆ†
      -- å°é¡¶å †æ•°æ®ï¼šä¸­ä½æ•°çš„ååŠéƒ¨åˆ†
# add
- ä¸¤è¾¹ä¸ªæ•°ä¸€æ ·æ—¶ï¼Œå·¦è¾¹ä¸ªæ•°åŠ ä¸€
- ä¸¤è¾¹ä¸ªæ•°ä¸ä¸€æ ·æ—¶ï¼Œå³è¾¹ä¸ªæ•°åŠ ä¸€

# addè§„åˆ™
- å·¦è¾¹ä¸ªæ•°åŠ ä¸€æ“ä½œï¼šå³æ·»åŠ æ–°å…ƒç´ ï¼Œå¼¹å‡ºå³è¾¹å †é¡¶å…ƒç´ åŠ å…¥å·¦è¾¹
- å³è¾¹é€»è¾‘ç±»ä¼¼
```

![image-20231029104600488](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029104600488.png)

```java
class MedianFinder {

    private PriorityQueue<Integer> leftMax = new PriorityQueue<>((a, b) -> (b - a));

    private PriorityQueue<Integer> rightMin = new PriorityQueue<>((a, b) -> (a - b));

    public MedianFinder() {
    }

    public void addNum(int num) {
        if (leftMax.size() == rightMin.size()) {
            // å·¦ä¸ªæ•°å¢åŠ é€»è¾‘
            rightMin.offer(num);
            Integer poll = rightMin.poll();
            leftMax.offer(poll);
        } else {
            // å³ä¸ªæ•°å¢åŠ é€»è¾‘
            leftMax.offer(num);
            Integer poll = leftMax.poll();
            rightMin.offer(poll);
        }
    }

    public double findMedian() {
        if (rightMin.size() == leftMax.size()) {
            return (leftMax.peek() + rightMin.peek()) / 2D;
        } else {
            return leftMax.peek();
        }
    }
}
```

# TOP-K

- å°é¡¶å †
- å‡¡æ˜¯æ¶‰åŠåˆ°æŒ‰ç…§æŸç§è§„åˆ™æ±‚ç¬¬Kçš„é—®é¢˜ï¼Œéƒ½å¯ä»¥è€ƒè™‘å †

```bash
# ä¸è¦ä¸€ä¸‹å­æŠŠæ‰€æœ‰å…ƒç´ æ·»åŠ è¿›å»ï¼Œè¿™æ ·å †æ¯”è¾ƒå¤§ï¼Œ å¤æ‚åº¦é«˜
- 0.åˆ¶å®šæ¯”è¾ƒè§„åˆ™
- 1. å‰k+1ä¸ªå…ƒç´ æ·»åŠ åˆ°å †ä¸­(offer)
- 2. (å¦‚æœæ˜¯k+1)ï¼Œåˆ™å¼¹å‡º1ä¸ªå…ƒç´ 
```

## âœ… [703. æ•°æ®æµä¸­çš„ç¬¬ K å¤§å…ƒç´ ](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)

```java
class KthLargest {
    private PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    private int capacity;

    public KthLargest(int k, int[] nums) {
        this.capacity = k;
        for (int i = 0; i < nums.length; i++) {
            offer(nums[i]);
        }
    }

    public int add(int val) {
        offer(val);
        return minHeap.peek();
    }

    private void offer(int val) {
        minHeap.offer(val);
        if (minHeap.size() > capacity) {
            minHeap.poll();
        }
    }
}
```

## ğŸ˜ [215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    for (int i = 0; i < k; i++) {
        minHeap.offer(nums[i]);
    }

    for (int i = k; i < nums.length; i++) {
        minHeap.offer(nums[i]);
        minHeap.poll();
    }
    return minHeap.peek();
}
```

## ğŸ˜ [2583. äºŒå‰æ ‘ä¸­çš„ç¬¬ K å¤§å±‚å’Œ](https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/)

- å…ˆæ±‚å‡ºå±‚åºçš„å’Œï¼Œç„¶ååˆ©ç”¨å°é¡¶å †è¿›è¡Œæ’åº
- ä»£ç ç•¥

## ğŸ˜ [347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/)

- éå†æ•´ä¸ªæ•°ç»„ï¼Œæ•°å­—ä½œä¸ºkeyï¼Œé¢‘æ¬¡ä½œä¸ºvalueï¼ŒåŠ å…¥åˆ°hashä¸­

```java
public int[] topKFrequent(int[] nums, int k) {
    PriorityQueue<Map.Entry<Integer, Integer>> minHeap =
            new PriorityQueue<>(new Comparator<Map.Entry<Integer, Integer>>() {
                @Override
                public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
                    return o1.getValue() - o2.getValue();
                }
            });

    for (Map.Entry<Integer, Integer> entry : getFrequency(nums).entrySet()) {
        minHeap.offer(entry);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }

    int[] result = new int[k];
    int idx = 0;
    while (!minHeap.isEmpty()) {
        result[idx] = minHeap.poll().getKey();
        idx++;
    }
    return result;
}

/*k:num   v: frequency*/
private Map<Integer, Integer> getFrequency(int[] nums) {
    Map<Integer, Integer> hash = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        if (!hash.containsKey(num)) {
            hash.put(num, 1);
        } else {
            hash.put(num, hash.get(num) + 1);
        }
    }
    return hash;
}
```

## ğŸ˜ [692. å‰Kä¸ªé«˜é¢‘å•è¯](https://leetcode.cn/problems/top-k-frequent-words/)

```java
public List<String> topKFrequent(String[] words, int k) {
    /*æ¯”è¾ƒè§„åˆ™*/
    PriorityQueue<Map.Entry<String, Integer>> minHeap =
            new PriorityQueue<>(new Comparator<Map.Entry<String, Integer>>() {
                @Override
                public int compare(Map.Entry<String, Integer> a, Map.Entry<String, Integer> b) {
                    if (!a.getValue().equals(b.getValue())) {
                        return a.getValue() - b.getValue();
                    } else {
                        return b.getKey().compareTo(a.getKey());
                    }
                }
            });


    /*æ’å…¥æ‰€æœ‰å…ƒç´ */
    for (Map.Entry<String, Integer> entry : getHash(words).entrySet()) {
        minHeap.offer(entry);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }

    List<String> result = new ArrayList<>();
    while (!minHeap.isEmpty()) {
        result.add(0, minHeap.poll().getKey());
    }
    return result;
}

private Map<String, Integer> getHash(String[] words) {
    Map<String, Integer> hash = new HashMap<>();
    for (int i = 0; i < words.length; i++) {
        String word = words[i];
        if (!hash.containsKey(word)) {
            hash.put(word, 1);
        } else {
            hash.put(word, hash.get(word) + 1);
        }
    }
    return hash;
}
```

# BOTTOM-K

- å¤§é¡¶å †

## ğŸ˜ [973. æœ€æ¥è¿‘åŸç‚¹çš„ K ä¸ªç‚¹](https://leetcode.cn/problems/k-closest-points-to-origin/)

```java
public int[][] kClosest(int[][] points, int k) {
    PriorityQueue<int[]> maxHeap =
            new PriorityQueue<>(new Comparator<int[]>() {
                @Override
                public int compare(int[] a, int[] b) {
                    return getDistance(b) - getDistance(a);
                }
            });

    for (int i = 0; i < points.length; i++) {
        maxHeap.offer(points[i]);
        if (maxHeap.size() > k) {
            maxHeap.poll();
        }
    }

    int[][] result = new int[maxHeap.size()][];
    int idx = 0;
    while (!maxHeap.isEmpty()) {
        result[idx] = maxHeap.poll();
        idx++;
    }
    return result;
}

private int getDistance(int[] arr) {
    return (int) (Math.pow(arr[0], 2) + Math.pow(arr[1], 2));
}
```

# ğŸ˜ [264. ä¸‘æ•° II](https://leetcode.cn/problems/ugly-number-ii/)

## å°é¡¶å † + Hash

```bash
# æ€è·¯
- æ¯æ¬¡pollçš„å…ƒç´ ï¼Œå°±æ˜¯å½“å‰æœ€å°çš„ï¼Œä¸€å…±poll næ¬¡ï¼Œå°±æ˜¯ç¬¬nä¸ªä¸‘æ•°
- æ¯æ¬¡pollæ—¶ï¼Œå°†2*pollï¼Œ3*pollï¼Œ5*pollåŠ å…¥åˆ°å°é¡¶å †ä¸­ï¼Œ æ·»åŠ æ—¶è¦ç”¨hashæ¥è¿›è¡Œå»é‡,é¿å…å †ä¸­å‡ºç°é‡å¤å…ƒç´ 

# ç¼ºç‚¹
- å°é¡¶å †ä¸­ä¼šç»´æŠ¤å¤šä½™è¦æ±‚nçš„ä¸‘æ•°
```

```java
public int nthUglyNumber(int n) {
    if (n == 1) {
        return 1;
    }

    Set<Long> hash = new HashSet<>();
    PriorityQueue<Long> minHeap = new PriorityQueue<>();
    minHeap.offer(1L);
    long result = -1;
    for (int i = 0; i < n; i++) {
        Long poll = minHeap.poll();
        result = poll;

        if (hash.add(poll * 2)) {
            minHeap.offer(poll * 2);
        }

        if (hash.add(poll * 3)) {
            minHeap.offer(poll * 3);
        }

        if (hash.add(poll * 5)) {
            minHeap.offer(poll * 5);
        }
    }
    return (int) result;
}
```

# ğŸ˜ [451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº](https://leetcode.cn/problems/sort-characters-by-frequency/)

## å¤§é¡¶å † + Hash

```java

    public String frequencySort(String s) {
        Map<Character, Integer> hash = getHash(s);

        PriorityQueue<Map.Entry<Character, Integer>> maxHeap =
                new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());

        for (Map.Entry<Character, Integer> entry : hash.entrySet()) {
            maxHeap.offer(entry);
        }

        StringBuilder sb = new StringBuilder();

        while (!maxHeap.isEmpty()) {
            Map.Entry<Character, Integer> poll = maxHeap.poll();
            for (int i = 0; i < poll.getValue(); i++) {
                sb.append(poll.getKey());
            }
        }
        return sb.toString();
    }

    private Map<Character, Integer> getHash(String s) {
        Map<Character, Integer> hash = new HashMap<>();
        char[] chs = s.toCharArray();
        for (char ch : chs) {
            if (!hash.containsKey(ch)) {
                hash.put(ch, 1);
            } else {
                hash.put(ch, hash.get(ch) + 1);
            }
        }
        return hash;
    }
```

